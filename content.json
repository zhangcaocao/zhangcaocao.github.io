{"meta":{"title":"一只电工的博客","subtitle":"little-rocket-blog","description":"一只电工的博客","author":"zhangcaocao","url":"http://little-rocket.cn"},"pages":[{"title":"Categories","date":"2018-03-17T04:31:21.885Z","updated":"2018-03-17T04:31:21.885Z","comments":true,"path":"categories/index.html","permalink":"http://little-rocket.cn/categories/index.html","excerpt":"","text":"(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s);})(); 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/categories/index.html"},{"title":"Tags","date":"2018-03-17T04:36:01.254Z","updated":"2018-03-17T04:36:01.254Z","comments":true,"path":"tags/index.html","permalink":"http://little-rocket.cn/tags/index.html","excerpt":"","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/tags/index.html"},{"title":"","date":"2018-03-18T04:52:39.862Z","updated":"2018-03-18T04:52:39.862Z","comments":true,"path":"about/index.html","permalink":"http://little-rocket.cn/about/index.html","excerpt":"","text":".github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}} (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 我的梦想与实现计划梦想总是要有的，万一实现了喃。不止一次谈过自己的梦想，往小的说，希望自己将来能够可以做自己感兴趣的事情。往大一点说，大概就是成为一只在某一领域有着自己的见解吧，能够做出一些东西为后面的人所使用，就像 Linus Benedict Torvalds 那样，成为人们心目中的偶像，拥有着Github Top 10 Star数的项目， 梦想的实现不是容易的。任何一项功能的实现都不是简单的，现在的我，C语言的代码量只有区区几千行，中间还有很多重复使用的。就连一个简单的命令行版本的操作系统内核都难以完成，因为我压根就没接触过汇编那些更底层的语言。大一便开始学习的Python，还停留在简单的爬虫阶段，无法利用它解决自己在数学上的大部分问题，满足自己的需求。然而在这种情况下，还在学习新的东西。例如 OpenCv， Ros等，，每一个都感觉足够自己学习一辈子了。。 有时候又感觉梦想离自己很近：毕竟我已经可以熟练的控制实验室的各种型号的有刷和无刷电机、熟悉Stm32。至少我知道自己在这个年龄该干点什么。有人说，将LeetCode的题刷2遍就可以进了半个谷歌。有人说，GitHub上面有着几个Star数目100+的项目，就可以进很多好企业，学长说，Robocon比赛得到一等奖甚至更高，就有机会去大疆。。 谈谈如何实现这个现实的问题：增长自己的视野，积极参与开源项目，提高自己的课程成绩，努力的做好比赛。改善自己的思维，达到很缜密的那种，大概就是高中分析化学反应曲线的那样吧。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/about/index.html"}],"posts":[{"title":"边缘检测-1、概述","slug":"边缘检测-1、概述","date":"2018-07-15T14:23:16.000Z","updated":"2018-07-15T14:40:12.209Z","comments":true,"path":"posts/边缘检测-1、概述.html","link":"","permalink":"http://little-rocket.cn/posts/边缘检测-1、概述.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 这篇文章为边缘检测的概述。","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 这篇文章为边缘检测的概述。 边缘检测概述：边缘存在条件： 表面法线不连续; 深度不连续; 表面颜色不连续; 光照(光线, 阴影等)的不连续. 边缘检测的步骤： 滤波。 灰度化。 检测边缘。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/边缘检测-1、概述.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://little-rocket.cn/tags/图像处理/"}]},{"title":"利用Robocon2018 比赛地图 + OpenCv + matplotlib拟合贝塞尔曲线，并且生成路径坐标点","slug":"利用Robocon-比赛地图-OpenCv-matplotlib拟合贝塞尔曲线，并且生成路径坐标点","date":"2018-04-19T04:10:58.000Z","updated":"2018-04-19T04:14:11.071Z","comments":true,"path":"posts/利用robocon2018-比赛地图-opencv-matplotlib拟合贝塞尔曲线，并且生成路径坐标点.html","link":"","permalink":"http://little-rocket.cn/posts/利用robocon2018-比赛地图-opencv-matplotlib拟合贝塞尔曲线，并且生成路径坐标点.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 本文内容： 贝塞尔曲线简介 代码算法讲解 总结 贝塞尔曲线简介：","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 本文内容： 贝塞尔曲线简介 代码算法讲解 总结 贝塞尔曲线简介： 原理：Github上一位大佬已经总结得很详细了, 还有动态图的哦,,我这里就直接引用啦Github 计算公式：此处引用简书一位大佬的总结:@L_Xian;该大佬不仅解释了贝塞尔曲线的原理，还详细的推导了贝塞尔曲线各阶公式之间的联系。 意义：此处只说一下对于全向机器人运动的意义：由于贝塞尔曲线是一条光滑的曲线，即高阶可导。若机器人的运动轨迹可以拟合在这条曲线上，运动转弯将更加顺滑，这就催生了我写这个小程序的想法。利用 Python强大的科学计算，图像处理，绘图能力。将一个标准的场地地图导入，二值化之后，使用在地图上点击的起点与终点已经2个控制点，绘制出3阶贝塞尔曲线，再经过坐标转换，生成适合场地的机器人运动轨迹坐标。 代码算法讲解： Gitub地址 获取鼠标点击的点：1234567891011121314151617class Get_Point_: # 使用OpenCv对图像进行初步的处理 # 使用 plt获取鼠标点击的坐标 def Get_Pos(src_img): plt.imshow(src_img, cmap=plt.get_cmap(\"gray\")) pos = plt.ginput(4) return pos def Get_Point(): return Points_List_ def Get_Image(): src_img = cv.imread('./img/changdi2.png') src_Gray_Image = cv.cvtColor(src_img, cv.COLOR_BGR2GRAY) ret, dst_Image = cv.threshold(src_Gray_Image, 98, 255, cv.THRESH_BINARY) return dst_Image Get_Pos(src_img): 使用plt显示图像，并且利用.ginput(n)获取n个鼠标点击的点的坐标，这样子的好处是，matplotlib可以很容易的放大缩小图像，且坐标轴方向相对使用OpenCv与实际更为接近。 Get_Image(): 使用OpenCV将图像灰度化然后二值化,便于观察绘制的曲线。 坐标点的解算：这里直接使用的3阶贝塞尔曲线的方程,解算出各个坐标点 12345678910# 解算Bezier方程的系数def Build_Bezier(Point_0, Point_1, Point_2, Point_3, t): A_0 = (1 - t) ** 3 A_1 = ((1 - t) ** 2) * 3 * t A_2 = (t ** 2) * (1 - t) * 3 A_3 = t ** 3 x = Point_0[0] * A_0 + Point_1[0] * A_1 + Point_2[0] * A_2 + Point_3[0] * A_3 y = Point_0[1] * A_0 + Point_1[1] * A_1 + Point_2[1] * A_2 + Point_3[1] * A_3 return [int(x), int(y)] # 坐标转换 return [int(x), int(y)]可以根据自己的需要对x， y进行转换之后再返回。 绘制图像此处我绘制了未拟合的坐标点(红色)，已经我们拟合出的路径(绿色)。可见上面的演示图 增加的功能：既然已经生成了理想的运动轨迹，大可再绘制实际的运动轨迹，只需要利用无线串口之类的模块将机器人的运动轨迹实时传回电脑，然后在场地上绘制出轨迹。如演示图中左上角的绿色的，不太和谐的绿色曲线，，emm，，那个只是我作的一个小实验，，随便弄的几个点，然后画在同一张图中这样子。。 总结：其实吧，，这个程序挺简单的，但是这个至少可以说明，自己完全可以利用程序实现自己的想法了。 GitHub 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/利用robocon2018-比赛地图-opencv-matplotlib拟合贝塞尔曲线，并且生成路径坐标点.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://little-rocket.cn/tags/项目/"}]},{"title":"记安装pyspectator填坑记","slug":"记安装pyspectator填坑记","date":"2018-04-14T16:44:40.000Z","updated":"2018-07-15T14:24:42.556Z","comments":true,"path":"posts/记安装pyspectator填坑记.html","link":"","permalink":"http://little-rocket.cn/posts/记安装pyspectator填坑记.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 记安装pyspectator填坑记：Environment INFO：windows10 + python3.5 1、正常安装官网12# Run as root user:pip install -U pyspectator_tornado Error INFO:1234567Collecting pyspectator_tornado Using cached pyspectator_tornado-1.1.2-py3-none-any.whlCollecting pyspectator&gt;=1.1.2 (from pyspectator_tornado) Using cached pyspectator-1.2.1.tar.gz Complete output from command python setup.py egg_info: error in pyspectator setup command: &apos;install_requires&apos; must be a string or list of strings containing valid project/version requirement specifiers; Invalid requirement, parse error at &quot;&apos;-r base.&apos;&quot; 解决办法:","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 记安装pyspectator填坑记：Environment INFO：windows10 + python3.5 1、正常安装官网12# Run as root user:pip install -U pyspectator_tornado Error INFO:1234567Collecting pyspectator_tornado Using cached pyspectator_tornado-1.1.2-py3-none-any.whlCollecting pyspectator&gt;=1.1.2 (from pyspectator_tornado) Using cached pyspectator-1.2.1.tar.gz Complete output from command python setup.py egg_info: error in pyspectator setup command: &apos;install_requires&apos; must be a string or list of strings containing valid project/version requirement specifiers; Invalid requirement, parse error at &quot;&apos;-r base.&apos;&quot; 解决办法: 下载源代码;打开Setup.py相关联的文件, 找到报错的地方: parse error at &quot;&#39;-r base.&#39;&quot;:直接搜索 base, 然后在“.\\pyspectator-1.2.1\\requirements”找到： 12-r base.txtwmi &gt;= 1.4.9 直接把第一行删除. 运行 python setup.py install1Finished processing dependencies for pyspectator==1.2.1 安装成功 2、再次运行：12# Run as root user:pip install -U pyspectator_tornado 123Requirement already up-to-date: wmi&gt;=1.4.9 in s:\\programdata\\anaconda3\\envs\\tensorflow\\lib\\site-packages\\wmi-1.4.9-py3.5.egg (from pyspectator&gt;=1.1.2-&gt;pyspectator_tornado)Installing collected packages: tornado, pyspectator-tornadoSuccessfully installed pyspectator-tornado-1.1.2 tornado-5.0. 安装成功 3、运行程序：123456How to useTo start working with pyspectator_tornado system you must execute file &quot;start.py&quot; in a root directory of project.Most simple method, where pyspectator_tornado will be binded on port &quot;8888&quot; and available by address: &quot;localhost:8888&quot;:$ python start.py 4、报错 “ImportError: No module named ‘psutil”安装 psutil：1pip install psutil 12345Collecting psutil Downloading psutil-5.4.5-cp35-cp35m-win_amd64.whl (222kB) 100% |████████████████████████████████| 225kB 7.1kB/sInstalling collected packages: psutilSuccessfully installed psutil-5.4.5 安装成功。 5、重复第三步。报错：1ImportError: No module named &apos;pyvalid&apos; 安装： 1pip install pyvalid 报错：123456789Using cached pyvalid-0.9.tar.bz2 Complete output from command python setup.py egg_info: Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;C:\\Users\\zcaoc\\AppData\\Local\\Temp\\pip-build-lpgjhgil\\pyvalid\\setup.py&quot;, line 75, in &lt;module&gt; main() File &quot;C:\\Users\\zcaoc\\AppData\\Local\\Temp\\pip-build-lpgjhgil\\pyvalid\\setup.py&quot;, line 23, in main long_description=open(&apos;README.rst&apos;).read(), UnicodeDecodeError: &apos;gbk&apos; codec can&apos;t decode byte 0x94 in position 800: illegal multibyte sequence 6、源码安装 pyvalid:(下载源代码](https://pypi.python.org/pypi/pyvalid/0.9#downloads)，打开`setup.py`，注释以下行： 123456789101112#long_description=open(&apos;README.rst&apos;).read(),install_requires=[],keywords=[ &apos;pyvalid&apos;, &apos;valid&apos;, &apos;validation&apos;, &apos;type&apos;, &apos;checking&apos;, &apos;check&apos;, &apos;decorator&apos;],platforms=&apos;Platform Independent&apos;,#package_data=&#123;# &apos;pyspectator&apos;: [&apos;LICENSE&apos;, &apos;README.rst&apos;]#&#125;, 目测，，那个README.rst没什么luan用。所以注释掉没关系； 然后，到目标文件夹运行： 1python setup.py install 123Installed s:\\programdata\\anaconda3\\envs\\tensorflow\\lib\\site-packages\\pyvalid-0.6-py3.5.eggProcessing dependencies for pyvalid==0.6Finished processing dependencies for pyvalid==0.6 成功安装。 7、重复第三步, 报错：ImportError: No module named &#39;netifaces&#39;.1pip install netifaces 1234Collecting netifaces Using cached netifaces-0.10.6-cp35-cp35m-win_amd64.whlInstalling collected packages: netifacesSuccessfully installed netifaces-0.10.6 成功安装。 8、重复第三步,报错：ImportError: No module named &#39;win32com&#39;下载whl文件安装： 1Successfully installed pywin32-223 成功安装。 9、重复第三步，成功运行。 总结：1、python包的安装，首先使用pip安装，如果安装失败，好好看看报错信息,, 试着利用setup.py安装。2、实不相瞒,, 为了安个包,, 我也是惊了。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/记安装pyspectator填坑记.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"日常填坑","slug":"日常填坑","permalink":"http://little-rocket.cn/tags/日常填坑/"}]},{"title":"Vs2013 + Pcl1.8.0安装教程","slug":"VS2013-PCL1-8-0安装教程","date":"2018-04-11T11:12:53.000Z","updated":"2018-04-11T11:16:59.444Z","comments":true,"path":"posts/vs2013-pcl1-8-0安装教程.html","link":"","permalink":"http://little-rocket.cn/posts/vs2013-pcl1-8-0安装教程.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 环境INFO： VS2013 + Win10 + PCL1.8.0 安装过程：在此可以查看 CSDN上的一篇博客, 他是直接使用的安装包安装, 不用编译那么多源码。","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 环境INFO： VS2013 + Win10 + PCL1.8.0 安装过程：在此可以查看 CSDN上的一篇博客, 他是直接使用的安装包安装, 不用编译那么多源码。 出现的问题： 1、安装选择安装的选项请注意查看, 比如我之前就已经安装了OpenNI2,我就不需要选择这个选项了。 2、安装后, 设置环境变量的时候, 可能会出现path too long installer unable to modify path这个问题, 没关系，自己重新配置环境变量就是了。 3、编译博主给的例子的时候, 出现error：fatal error C1076: compiler limit : internal heap limit reached; use /Zm to specify a higher limit 此时可以按照编译器说的，增加\\Zm的值： 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/vs2013-pcl1-8-0安装教程.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"PCL","slug":"PCL","permalink":"http://little-rocket.cn/tags/PCL/"}]},{"title":"【OpenCvTutorials3-1中文翻译】- 平滑图像","slug":"【OpenCvTutorials3-1中文翻译】-平滑图像","date":"2018-03-12T09:09:04.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-平滑图像.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-平滑图像.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); Smoothing ImagesGoal在本教程中，您将学习如何使用OpenCV函数应用各种线性滤波器来平滑图像，比如说： cv::blurcv::GaussianBlurcv::medianBlurcv::bilateralFilter","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); Smoothing ImagesGoal在本教程中，您将学习如何使用OpenCV函数应用各种线性滤波器来平滑图像，比如说： cv::blurcv::GaussianBlurcv::medianBlurcv::bilateralFilter Theory Note: The explanation below belongs to the book Computer Vision: Algorithms and Applications by Richard Szeliski and to LearningOpenCV .. container:: enumeratevisibleitemswithsquare 平滑(Smoothing)，也称为模糊(blurring)，是一种简单且经常使用的图像处理操作。 平滑有很多原因。 在本教程中，我们将重点关注平滑以减少噪音（其他用途将在以下教程中看到）。 要执行平滑操作，我们将对图像应用滤波器。 最常见的滤波器类型是线性的，其中输出像素值(即 $g(i，j)$)被确定为输入像素值（即 $f(i + k，j + 1))$的加权和： $$g(i,j) = \\sum_{k,l} f(i+k, j+l) h(k,l)$$ $h(k,l)$ 被称为内核，它不过是滤波器的系数。它有助于将滤波器可视化为系数在图像上滑动的窗口。 有很多类型的过滤器，在这里我们会提到最常用的： Normalized Box Filter(归一化) 这个过滤器是最简单的！ 每个输出像素是其内核邻居的平均值（所有这些都是以相同的权重作出贡献的） 内核如下： Gaussian Filter 可能是最有用的过滤器（尽管不是最快的）。滤波是通过将输入数组中的每个点与高斯内核进行卷积然后将它们相加以产生输出数组来完成的。 为了让图像更清晰，请记住一维高斯内核的是怎样的？ 假设图像是1D，您可以注意到位于中间的像素将具有最大的权重。 其邻居的权重随着它们与中心像素之间的空间距离的增加而减小。 Note:请记住，二维高斯可以表示为： 其中$μ$是平均值（峰值），$σ$表示方差（每个变量$x$和$y$） Median Filter中值滤波器贯穿信号的每个元素（在这种情况下是图像），并用每个像素的相邻像素的中值（位于评估像素周围的正方形邻域中）替换每个像素。 Bilateral Filter(双边滤波) 到目前为止，我们已经解释了一些滤波器，其主要目标是平滑输入图像。 但是，有时滤波器不仅会消除噪音，还会消除边缘。 为了避免这种情况（至少在某种程度上），我们可以使用双边滤波器。 以与高斯滤波器类似的方式，双边滤波器也考虑分配给它们中的每一个相邻像素一个权重。 这些权重有两个分量，第一个是高斯滤波器使用的相同权重。 第二部分考虑了相邻像素与评估像素之间强度的差异。 关于更详细的解释你可以查看这个链接 Code 这个程序做什么？ 加载一张图 应用4种不同类型的过滤器（在 Theory 中解释了的）并顺序显示过滤后的图像 Downloadable code: Click here 代码一览: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include \"opencv2/imgproc.hpp\"#include \"opencv2/highgui.hpp\"using namespace std;using namespace cv;int DELAY_CAPTION = 1500;int DELAY_BLUR = 100;int MAX_KERNEL_LENGTH = 31;Mat src; Mat dst;char window_name[] = \"Filter Demo 1\";int display_caption( char* caption );int display_dst( int delay );/* * function main */ int main( int argc, char** argv ) &#123; namedWindow( window_name, WINDOW_AUTOSIZE ); src = imread( \"../images/lena.jpg\", 1 ); if( display_caption( \"Original Image\" ) != 0 ) &#123; return 0; &#125; dst = src.clone(); if( display_dst( DELAY_CAPTION ) != 0 ) &#123; return 0; &#125; if( display_caption( \"Homogeneous Blur\" ) != 0 ) &#123; return 0; &#125; for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; blur( src, dst, Size( i, i ), Point(-1,-1) ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; if( display_caption( \"Gaussian Blur\" ) != 0 ) &#123; return 0; &#125; for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; GaussianBlur( src, dst, Size( i, i ), 0, 0 ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; if( display_caption( \"Median Blur\" ) != 0 ) &#123; return 0; &#125; for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; medianBlur ( src, dst, i ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; if( display_caption( \"Bilateral Blur\" ) != 0 ) &#123; return 0; &#125; for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; bilateralFilter ( src, dst, i, i*2, i/2 ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; display_caption( \"End: Press a key!\" ); waitKey(0); return 0; &#125; int display_caption( char* caption ) &#123; dst = Mat::zeros( src.size(), src.type() ); putText( dst, caption, Point( src.cols/4, src.rows/2), FONT_HERSHEY_COMPLEX, 1, Scalar(255, 255, 255) ); imshow( window_name, dst ); int c = waitKey( DELAY_CAPTION ); if( c &gt;= 0 ) &#123; return -1; &#125; return 0; &#125; int display_dst( int delay ) &#123; imshow( window_name, dst ); int c = waitKey ( delay ); if( c &gt;= 0 ) &#123; return -1; &#125; return 0; &#125; Explanation(解释)1、让我们来看看只涉及平滑过程的OpenCV函数，因为掌握这个之后其余的内容就已经知道了。2、 Normalized Block Filter:OpenCV提供cv::blur函数来执行此滤波器的平滑处理。 123for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; blur( src, dst, Size( i, i ), Point(-1,-1) ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; 我们指定了4个参数（更多细节，请参阅参考资料）： src：源图像 dst：目标图像 size（w，h）：定义要使用的内核的大小（宽度w像素和高度h像素） Point（-1，-1）：指示参考点（评估像素）相对于邻域的位置。 如果存在负值，那么内核的中心被认为是参考点。 3、Gaussian Filter:它由cv::GaussianBlur函数执行： 12345for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; GaussianBlur( src, dst, Size( i, i ), 0, 0 ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; 这里我们指定了4个参数（更多细节，请参阅参考资料）： src：源图像 dst：目标图像 size（w，h）：要使用的内核的大小（the neighbors to be considered）。 m和h必须是奇数和正数，否则将使用σx和σy参数计算大小。 σx：x中的标准差。 写0意味着σx是使用内核大小计算的。 σy：y中的标准差。 写0意味着使用内核大小来计算σy。 4、Median Filter:该过滤器由cv::medianBlur函数提供： 123for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; medianBlur ( src, dst, i ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; 我们使用了3个参数： Src:源图像 dst:目标图像 i：内核的大小（只有一个，因为我们使用一个方形窗口）。必须是奇数。 5、Bilateral Filter：cv::bilateralFilter 123for ( int i = 1; i &lt; MAX_KERNEL_LENGTH; i = i + 2 ) &#123; bilateralFilter ( src, dst, i, i*2, i/2 ); if( display_dst( DELAY_BLUR ) != 0 ) &#123; return 0; &#125; &#125; 我们使用了5个参数： src:源图像 dst:目标图像 d： 每个像素邻域的直径。 $\\sigma_{Color}$ : 色彩空间中的标准偏差。 $\\sigma_{Space}$ : 坐标空间中的标准偏差（以像素为单位） Results 该代码打开一个图像（在本例中为lena.jpg），并在所解释的4个过滤器的效果下显示。 以下是使用medianBlur平滑图像的快照： 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-平滑图像.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"使用OpenCV+C++将Gif文件分解并且转换为视频文件","slug":"使用OpenCv和Cpp-将Gif文件分解并且转换为视频文件","date":"2018-03-03T08:00:22.000Z","updated":"2018-03-12T09:11:03.331Z","comments":true,"path":"posts/使用opencv-c-将gif文件分解并且转换为视频文件.html","link":"","permalink":"http://little-rocket.cn/posts/使用opencv-c-将gif文件分解并且转换为视频文件.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 目标： 认识 Gif 利用 FreeImage 将Gif解析为 Mat； 利用 FreeImage 获取多帧Gif图像； 将获取的多帧图像保存，并利用OpenCv生成为视频文件。 实际操作：","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 目标： 认识 Gif 利用 FreeImage 将Gif解析为 Mat； 利用 FreeImage 获取多帧Gif图像； 将获取的多帧图像保存，并利用OpenCv生成为视频文件。 实际操作： 认识 Gif：在浏览器中输入 Gif，查看维基百科的解释：关于科学上网的方法可以查看 自建ssr/ss科学上网服务器 在这里，我将其下载为了PDF，供大家下载：点击下载 我们注意它的特性就可以了： 1234优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。可插入多帧，从而实现动画效果。可设置透明色以产生对象浮现于背景之上的效果。由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。 算法解析：环境： OpenCv3.1 window10 vs2013 FreeImage OpenCv 3.1官方教程中文翻译链接FreeImage 下载地址FreeImage是没有文档的，搜索之后，在网上发现一个写得还不错的文档点击下载 环境搭建：新建一个OpenCv的工程， 下载FreeImage，将相应的文件复制到工程文件夹下： 将.lib 文件添加到工程： 如此便搭建好了环境。 算法实现：Gif文件的加载：代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//------------- GIF文件的载入//bool Gif_Load(const string &amp;filename)&#123; FIBITMAP *dib = 0; FIMULTIBITMAP *bitmap = 0; FIBITMAP * pFrame; fif = FreeImage_GetFileType(filename.c_str(), 0); if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(filename.c_str()); if (fif == FIF_UNKNOWN) return false; if (FreeImage_FIFSupportsReading(fif)) dib = FreeImage_Load(fif, filename.c_str()); if (!dib) return false;//dib Load failed //bpp = FreeImage_GetBPP(dib); bits = (BYTE*)FreeImage_GetBits(dib); width = FreeImage_GetWidth(dib); height = FreeImage_GetHeight(dib); cout &lt;&lt; \"Load The File: \" &lt;&lt; filename.c_str() &lt;&lt; endl; cout &lt;&lt; \"The File's width: \" &lt;&lt; width &lt;&lt; endl; cout &lt;&lt; \"The File's height: \" &lt;&lt; height &lt;&lt; endl; if ((bits == 0) || (width == 0) || (height == 0)) return false; bitmap = FreeImage_OpenMultiBitmap(fif, filename.c_str(), 0, 0, 1, GIF_DEFAULT); if (bitmap == NULL) &#123; cout &lt;&lt; \"BitMap == Null\" &lt;&lt; endl; return FALSE; &#125; int count = FreeImage_GetPageCount(bitmap);//获取帧数； for (int i = 0; i &lt;=count; i++) &#123; pFrame = FreeImage_LockPage(bitmap, i); //cout &lt;&lt; \"pFrame:\" &lt;&lt; pFrame &lt;&lt; endl; Src_Gif = Gif_To_Mat(pFrame, fif); //转换为Mat； string Src_Gif_Name = to_string(i); imwrite(Src_Gif_Name + \".jpg\", Src_Gif); FreeImage_UnlockPage(bitmap, pFrame, 1); &#125; FreeImage_Unload(dib); FreeImage_DeInitialise(); Load_flag = TRUE; return Load_flag;&#125; 解释： 首先是利用 FreeImage_GetFileType()函数，通过文件名，获取文件的类型； 然后判断 FreeImage_FIFSupportsReading()，是否是FreeImage支持的文件类型； 之后获取文件的相关信息，位数，大小。 再利用 FreeImage_OpenMultiBitmap，以 GIF_DEFAULT 的方式加载Gif文件，关于这个函数参数的意义，可查看我上面给出的文档。 利用 FreeImage_GetPageCount 函数获取帧数。 之后就是在一个for循环里面，使用 Gif_To_Mat，将每一帧图片转换为Mat。 再使用 imwrite 将图像储存到本地。 由此Gif加载完毕，并且转换为了Mat。下面来解释一下Gif转换为Mat的方法： Gif转换为Mat：代码：123456789101112131415161718192021222324252627282930313233Mat Gif_To_Mat(FIBITMAP* fiBmp, const FREE_IMAGE_FORMAT fif)&#123; if (fiBmp == NULL || fif != FIF_GIF) &#123; return Mat(); &#125; BYTE intensity; BYTE* PIintensity = &amp;intensity; if (FreeImage_GetBPP(fiBmp) != 8) fiBmp = FreeImage_ConvertTo8Bits(fiBmp); RGBQUAD* pixels = new RGBQUAD; pixels = FreeImage_GetPalette(fiBmp); Mat img = Mat::zeros(height, width, CV_8UC3); uchar *p; for (int i = 0; i &lt; height; i++) &#123; p = img.ptr&lt;uchar&gt;(i); for (int j = 0; j &lt; width; j++) &#123; FreeImage_GetPixelIndex(fiBmp, j, height - i, PIintensity); p[3 * j] = pixels[intensity].rgbBlue; p[3 * j + 1] = pixels[intensity].rgbGreen; p[3 * j + 2] = pixels[intensity].rgbRed; &#125; &#125; return img;&#125; 解释： for 循环之前图像的加载不需要多说了； for 循环，遍历整个图像，利用 FreeImage_GetPixelIndex 获取相应（x， y）的像素值，注意这里的坐标 表示的是（j， height-1），因为坐标的x， y 和 height， width是不一样的；大可将 height-i 改为i运行查看区别。 关于对图像的遍历，可参考【OpenCvTutorials3.1中文翻译】- 如何使用OpenCV扫描图像，查找表和时间测量，这里有详细的解释。 将文件夹中的jpg文件合成为视频：代码：12345678910111213141516171819202122232425//将当前文件夹中的 “.jpg” 生成为视频文件；bool Jpg_To_Video()&#123; VideoWriter video(\"output.avi\", CV_FOURCC('M', 'P', '4', '2'), 25.0, Size(150, 131)); String File_Name = \"*.jpg\"; vector &lt;String&gt; fn; glob(File_Name, fn, false);//遍历文件夹的图片/文件 size_t size = fn.size(); cout &lt;&lt; \"Jpg_To_Video size:\" &lt;&lt; size &lt;&lt; endl; cout &lt;&lt; \"开始将图片文件写入视频\" &lt;&lt; endl; for (size_t i = 0; i &lt; size; i++) &#123; Mat image = imread(fn[i]); //imshow(to_string(i), image); //resize(image, image, Size(640, 480)); //这里 必须将image的大小 转换为 VideoWriter video(...)一样的大小。 video.write(image); &#125; cout &lt;&lt; \"写入 成功!\" &lt;&lt; endl; return TRUE;&#125; 解释： 这里大多是OpenCv的基础知识，唯一需要解释的是我们使用了 glob 函数。该函数的使用可参考 链接 至此，已经获取Gif文件的多帧图像，并且保存为了视频文件，接下来我们将它显示出来。 显示生成的视频文件：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980bool Show_Video()&#123; cout &lt;&lt; \"Show The Video..\" &lt;&lt; endl; VideoCapture video_capture(\"output.avi\"); if (!video_capture.isOpened()) return FALSE; double totalFrameNumber = video_capture.get(CV_CAP_PROP_FRAME_COUNT); cout &lt;&lt; \"整个视频共\" &lt;&lt; totalFrameNumber &lt;&lt; \"帧\" &lt;&lt; endl; //设置开始帧() long frameToStart = 1; video_capture.set(CV_CAP_PROP_POS_FRAMES, frameToStart); cout &lt;&lt; \"从第\" &lt;&lt; frameToStart &lt;&lt; \"帧开始读\" &lt;&lt; endl; //设置结束帧 int frameToStop = totalFrameNumber; if (frameToStop &lt; frameToStart) &#123; cout &lt;&lt; \"结束帧小于开始帧，程序错误，即将退出！\" &lt;&lt; endl; return FALSE; &#125; else &#123; cout &lt;&lt; \"结束帧为：第\" &lt;&lt; frameToStop &lt;&lt; \"帧\" &lt;&lt; endl; &#125; //获取帧率 double rate = video_capture.get(CV_CAP_PROP_FPS); cout &lt;&lt; \"帧率为:\" &lt;&lt; rate &lt;&lt; endl; //定义一个用来控制读取视频循环结束的变量 bool stop = false; //承载每一帧的图像 Mat frame; //显示每一帧的窗口 namedWindow(\"Extracted frame\"); //两帧间的间隔时间: double delay = rate; //利用while循环读取帧 //currentFrame是在循环体中控制读取到指定的帧后循环结束的变量 long currentFrame = frameToStart; while (!stop) &#123; //读取下一帧 if (!video_capture.read(frame)) &#123; cout &lt;&lt; \"读取视频结束\" &lt;&lt; endl; return FALSE; &#125; imshow(\"Extracted frame\", frame); cout &lt;&lt; \"正在读取第\" &lt;&lt; currentFrame &lt;&lt; \"帧\" &lt;&lt; endl; //waitKey(int delay=0)当delay ≤ 0时会永远等待；当delay&gt;0时会等待delay毫秒 //当时间结束前没有按键按下时，返回值为-1；否则返回按键 int c = waitKey(delay); //按下ESC键退出视频的帧流显示 if ((char)c == 27 || currentFrame &gt; frameToStop) &#123; stop = true; &#125; //按下按键后会停留在当前帧，等待下一次按键 if (c &gt;= 0) &#123; waitKey(0); &#125; currentFrame++; &#125; //关闭视频文件 video_capture.release(); waitKey(0); return TRUE;&#125; 解释： 这段代码有详细的注释，不再赘言。 运行结果以及源代码： GutHub：GitHub 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/使用opencv-c-将gif文件分解并且转换为视频文件.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCv","slug":"OpenCv","permalink":"http://little-rocket.cn/tags/OpenCv/"},{"name":"项目","slug":"项目","permalink":"http://little-rocket.cn/tags/项目/"}]},{"title":"复变函数与积分变换知识点总结【1】","slug":"复变函数与积分变换知识点总结【1】","date":"2018-02-25T03:27:37.000Z","updated":"2018-02-25T13:49:53.738Z","comments":true,"path":"posts/复变函数与积分变换知识点总结【1】.html","link":"","permalink":"http://little-rocket.cn/posts/复变函数与积分变换知识点总结【1】.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 总是记不住那些皮砍子公式：震惊，我哪里记得到那么多嘛，这些公式知道在哪里就行了嘛，需要的时候再查查。 在这里总结一下，正好熟悉一下公式编辑。 内容：复变函数：","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 总是记不住那些皮砍子公式：震惊，我哪里记得到那么多嘛，这些公式知道在哪里就行了嘛，需要的时候再查查。 在这里总结一下，正好熟悉一下公式编辑。 内容：复变函数： 占坑 复数的几何表示：复数的乘幂于方根：解析函数：级数：复变函数的积分：留数：积分变换：傅里叶变换：拉普拉斯变换： 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/复变函数与积分变换知识点总结【1】.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://little-rocket.cn/tags/复变函数/"},{"name":"课程总结","slug":"课程总结","permalink":"http://little-rocket.cn/tags/课程总结/"}]},{"title":"这个可能是整理得最完整的学习资料列表！！！！","slug":"这个可能是最完整的学习列表！！！！","date":"2018-02-22T16:29:21.000Z","updated":"2018-03-01T09:48:00.124Z","comments":true,"path":"posts/这个可能是整理得最完整的学习资料列表！！！！.html","link":"","permalink":"http://little-rocket.cn/posts/这个可能是整理得最完整的学习资料列表！！！！.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 晚上逛GitHub，已经由Github粉转为脑残粉了，，这个可能是史上最完整的学习列表了！！！传送门： GitHub-awesome 预览：","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 晚上逛GitHub，已经由Github粉转为脑残粉了，，这个可能是史上最完整的学习列表了！！！传送门： GitHub-awesome 预览： Contents： 以下是一些分别的内容： 点开一项C++： 最后：话不多说，，强调一下传送门。传送门. 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/这个可能是整理得最完整的学习资料列表！！！！.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"资源分享","slug":"资源分享","permalink":"http://little-rocket.cn/tags/资源分享/"}]},{"title":"树莓派搭建Git 服务","slug":"树莓派搭建Git-服务","date":"2018-02-22T08:06:53.000Z","updated":"2018-03-12T09:10:39.983Z","comments":true,"path":"posts/树莓派搭建git-服务.html","link":"","permalink":"http://little-rocket.cn/posts/树莓派搭建git-服务.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 写好的代码一定要备份！！写过嵌入式的小伙伴可能都遇到过，自己写好的代码，实现了基本功能之后，改一改就改不回去了。。。。然后一直就调不出来气得吐血！！的情况。高呼，昨天还是好好的 /捂脸。。有些工程，又不方便发布到Github 。确实版本控制挺棒的，正好手里有一块树莓派，于是想着自己搭建一个Git服务器。 搭建过程：","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); 写好的代码一定要备份！！写过嵌入式的小伙伴可能都遇到过，自己写好的代码，实现了基本功能之后，改一改就改不回去了。。。。然后一直就调不出来气得吐血！！的情况。高呼，昨天还是好好的 /捂脸。。有些工程，又不方便发布到Github 。确实版本控制挺棒的，正好手里有一块树莓派，于是想着自己搭建一个Git服务器。 搭建过程： 工具： Git 树莓派3 具体过程：SSH连接：打开Git， 输入：1ssh pi@ 192.168.1.101 #Pi 是树莓派的用户名， 192.168.1.101是树莓派的IP地址。 安装Git服务器和必要的客户端软件：1sudo apt-get install wget git-core 添加一个”Git”用户和组:添加：1sudo adduser --system --shell /bin/bash --gecos 'git version control by pi' --group --home /home/git git 修改密码：1passwd git 切换用户：1su git 实例：增加一个Git仓库（树莓派上操作）：切换到Git目录下：1cd /home/git 创建仓库并且初始化：12345mkdir test.gitcd test.gitgit ——bare init Push 你的代码到树莓派上（本地操作）：将刚刚创建的仓库 Clone到一个文件夹：1git clone git@192.168.1.101:/home/git/test.git 将你的代码放到该文件夹中：加入一个新的远程主机:1git remote add origin git@192.168.1.101 :/home/git/test.git add增加你的代码， commit提交到本地， 然后push到远程：12345git add .git commit -am \"Initial\"git push origin master 类似这样的消息”authenticity of host …”只需要输入”yes”然后继续就可以了。如果一切正常，你的Git仓库已经搭建在你的树莓派上了。 在到另一个文件夹，将刚刚那个仓库Clone下来，若一切正常，则搭建成功了。1git clone git@192.168.1.101:/home/git/test.git 最后： Pro Git，第二版，简体中文 GitBook 妈妈再也不用担心我的代码，改不回去了。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/树莓派搭建git-服务.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://little-rocket.cn/tags/项目/"},{"name":"树莓派","slug":"树莓派","permalink":"http://little-rocket.cn/tags/树莓派/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 使用XML和YAML文件的文件输入和输出","slug":"【OpenCvTutorials3-1中文翻译】-使用XML和YAML文件的文件输入和输出","date":"2018-02-16T11:01:49.000Z","updated":"2018-07-15T13:23:40.681Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-使用xml和yaml文件的文件输入和输出.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-使用xml和yaml文件的文件输入和输出.html","excerpt":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); File Input and Output using XML and YAML filesGoal:你会找到以下问题的答案： 如何使用YAML或XML文件将文本条目打印并读取到文件和OpenCV？ 如何为OpenCV数据结构做同样的事情？ 如何为你的数据结构做到这一点？ OpenCV的数据结构，例如CV::FileStorage，CV::filenode 的或CV::FileNodeIterator的使用。","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); File Input and Output using XML and YAML filesGoal:你会找到以下问题的答案： 如何使用YAML或XML文件将文本条目打印并读取到文件和OpenCV？ 如何为OpenCV数据结构做同样的事情？ 如何为你的数据结构做到这一点？ OpenCV的数据结构，例如CV::FileStorage，CV::filenode 的或CV::FileNodeIterator的使用。 Source code:你可以从这里下载， 也可以在samples/cpp/tutorial_code/core/file_input_output/file_input_output.cpp找到：以下是如何实现目标列表中列举的所有东西的示例代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;opencv2/core/core.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace cv;using namespace std;static void help(char** av)&#123; cout &lt;&lt; endl &lt;&lt; av[0] &lt;&lt; \" shows the usage of the OpenCV serialization functionality.\" &lt;&lt; endl &lt;&lt; \"usage: \" &lt;&lt; endl &lt;&lt; av[0] &lt;&lt; \" outputfile.yml.gz\" &lt;&lt; endl &lt;&lt; \"The output file may be either XML (xml) or YAML (yml/yaml). You can even compress it by \" &lt;&lt; \"specifying this in its extension like xml.gz yaml.gz etc... \" &lt;&lt; endl &lt;&lt; \"With FileStorage you can serialize objects in OpenCV by using the &lt;&lt; and &gt;&gt; operators\" &lt;&lt; endl &lt;&lt; \"For example: - create a class and have it serialized\" &lt;&lt; endl &lt;&lt; \" - use it to read and write matrices.\" &lt;&lt; endl;&#125;class MyData&#123;public: MyData() : A(0), X(0), id() &#123;&#125; explicit MyData(int) : A(97), X(CV_PI), id(\"mydata1234\") // explicit to avoid implicit conversion &#123;&#125; void write(FileStorage&amp; fs) const //Write serialization for this class &#123; fs &lt;&lt; \"&#123;\" &lt;&lt; \"A\" &lt;&lt; A &lt;&lt; \"X\" &lt;&lt; X &lt;&lt; \"id\" &lt;&lt; id &lt;&lt; \"&#125;\"; &#125; void read(const FileNode&amp; node) //Read serialization for this class &#123; A = (int)node[\"A\"]; X = (double)node[\"X\"]; id = (string)node[\"id\"]; &#125;public: // Data Members int A; double X; string id;&#125;;//These write and read functions must be defined for the serialization in FileStorage to workstatic void write(FileStorage&amp; fs, const std::string&amp;, const MyData&amp; x)&#123; x.write(fs);&#125;static void read(const FileNode&amp; node, MyData&amp; x, const MyData&amp; default_value = MyData())&#123; if(node.empty()) x = default_value; else x.read(node);&#125;// This function will print our custom class to the consolestatic ostream&amp; operator&lt;&lt;(ostream&amp; out, const MyData&amp; m)&#123; out &lt;&lt; \"&#123; id = \" &lt;&lt; m.id &lt;&lt; \", \"; out &lt;&lt; \"X = \" &lt;&lt; m.X &lt;&lt; \", \"; out &lt;&lt; \"A = \" &lt;&lt; m.A &lt;&lt; \"&#125;\"; return out;&#125;int main(int ac, char** av)&#123; if (ac != 2) &#123; help(av); return 1; &#125; string filename = av[1]; &#123; //write Mat R = Mat_&lt;uchar&gt;::eye(3, 3), T = Mat_&lt;double&gt;::zeros(3, 1); MyData m(1); FileStorage fs(filename, FileStorage::WRITE); fs &lt;&lt; \"iterationNr\" &lt;&lt; 100; fs &lt;&lt; \"strings\" &lt;&lt; \"[\"; // text - string sequence fs &lt;&lt; \"image1.jpg\" &lt;&lt; \"Awesomeness\" &lt;&lt; \"../data/baboon.jpg\"; fs &lt;&lt; \"]\"; // close sequence fs &lt;&lt; \"Mapping\"; // text - mapping fs &lt;&lt; \"&#123;\" &lt;&lt; \"One\" &lt;&lt; 1; fs &lt;&lt; \"Two\" &lt;&lt; 2 &lt;&lt; \"&#125;\"; fs &lt;&lt; \"R\" &lt;&lt; R; // cv::Mat fs &lt;&lt; \"T\" &lt;&lt; T; fs &lt;&lt; \"MyData\" &lt;&lt; m; // your own data structures fs.release(); // explicit close cout &lt;&lt; \"Write Done.\" &lt;&lt; endl; &#125; &#123;//read cout &lt;&lt; endl &lt;&lt; \"Reading: \" &lt;&lt; endl; FileStorage fs; fs.open(filename, FileStorage::READ); int itNr; //fs[\"iterationNr\"] &gt;&gt; itNr; itNr = (int) fs[\"iterationNr\"]; cout &lt;&lt; itNr; if (!fs.isOpened()) &#123; cerr &lt;&lt; \"Failed to open \" &lt;&lt; filename &lt;&lt; endl; help(av); return 1; &#125; FileNode n = fs[\"strings\"]; // Read string sequence - Get node if (n.type() != FileNode::SEQ) &#123; cerr &lt;&lt; \"strings is not a sequence! FAIL\" &lt;&lt; endl; return 1; &#125; FileNodeIterator it = n.begin(), it_end = n.end(); // Go through the node for (; it != it_end; ++it) cout &lt;&lt; (string)*it &lt;&lt; endl; n = fs[\"Mapping\"]; // Read mappings from a sequence cout &lt;&lt; \"Two \" &lt;&lt; (int)(n[\"Two\"]) &lt;&lt; \"; \"; cout &lt;&lt; \"One \" &lt;&lt; (int)(n[\"One\"]) &lt;&lt; endl &lt;&lt; endl; MyData m; Mat R, T; fs[\"R\"] &gt;&gt; R; // Read cv::Mat fs[\"T\"] &gt;&gt; T; fs[\"MyData\"] &gt;&gt; m; // Read your own structure_ cout &lt;&lt; endl &lt;&lt; \"R = \" &lt;&lt; R &lt;&lt; endl; cout &lt;&lt; \"T = \" &lt;&lt; T &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"MyData = \" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl &lt;&lt; endl; //Show default behavior for non existing nodes cout &lt;&lt; \"Attempt to read NonExisting (should initialize the data structure with its default).\"; fs[\"NonExisting\"] &gt;&gt; m; cout &lt;&lt; endl &lt;&lt; \"NonExisting = \" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl; &#125; cout &lt;&lt; endl &lt;&lt; \"Tip: Open up \" &lt;&lt; filename &lt;&lt; \" with a text editor to see the serialized data.\" &lt;&lt; endl; return 0;&#125; Explanation:这里我们只讨论XML和YAML文件输入。您的输出（及其各自的输入）文件可能只有其中一个扩展名和结构来自此。它们是可以序列化的两种数据结构：映射（如STL映射）和元素序列（如STL向量）（mappings (like the STL map) and element sequence (like the STL vector). ）。它们之间的区别在于： 在map中，每个元素都可以通过您可以访问的内容获得唯一的名称。 对于序列（sequences ），您需要通过它们来查询特定项目。 1、XML / YAML文件的打开和关闭XML / YAML文件打开和关闭。在将任何内容写入此类文件之前，您需要打开它并在最后关闭它。OpenCV中的XML / YAML数据结构是cv::FileStorage。要指定这个文件绑定到硬盘上的结构，你可以使用它的构造函数或open（）函数：1234string filename = \"I.xml\";FileStorage fs(filename, FileStorage::WRITE);//...fs.open(filename, FileStorage::READ); 您使用第二个参数的其中一个参数是一个常量，指定您可以在其上执行的操作类型：WRITE，READ或APPEND。在文件名中指定的扩展名也决定了将要使用的输出格式。如果您指定了例如 .xml.gz 的扩展名，则输出将会被压缩。 该文件在 cv :: FileStorage 对象被销毁时自动关闭。 但是，您可以通过使用release 函数来显式调用它： 1fs.release(); // explicit close 2、输入和输出文字和数字数据结构使用与STL库相同的 &lt;&lt; 输出运算符。为了输出任何类型的数据结构，我们首先需要指定它的名称。我们只需打印出这个名字就可以做到这一点。对于基本类型和它的值，您可以按照以下打印：1fs &lt;&lt; \"iterationNr\" &lt;&lt; 100; 读入是一个简单的寻址(addressing )（通过[]运算符）和铸造(casting )操作或通过&gt;&gt;操作符读取：123int itNr;fs[\"iterationNr\"] &gt;&gt; itNr;itNr = (int) fs[\"iterationNr\"]; 3、OpenCV数据结构的输入/输出。这些操作就像基本的C ++类型一样：123456Mat R = Mat_&lt;uchar &gt;::eye (3, 3), T = Mat_&lt;double&gt;::zeros(3, 1);fs &lt;&lt; \"R\" &lt;&lt; R; // Write cv::Matfs &lt;&lt; \"T\" &lt;&lt; T;fs[\"R\"] &gt;&gt; R; // Read cv::Matfs[\"T\"] &gt;&gt; T; 4、矢量（数组）和关联图的输入/输出。正如我之前提到的，我们也可以输出映射(maps)和序列(sequences)（数组，矢量）。我们再次首先打印变量的名称，然后我们必须指定我们的输出是序列(sequences)还是映射(maps)。对于第一个元素之前的序列(sequences)，打印“[”字符 并在最后一个之后打印“]”字符： 123fs &lt;&lt; \"strings\" &lt;&lt; \"[\"; // text - string sequencefs &lt;&lt; \"image1.jpg\" &lt;&lt; \"Awesomeness\" &lt;&lt; \"baboon.jpg\";fs &lt;&lt; \"]\"; // close sequence 对于映射(maps)而言，练习是相同的，但现在我们使用“{”和“}”分隔符： 123fs &lt;&lt; \"Mapping\"; // text - mappingfs &lt;&lt; \"&#123;\" &lt;&lt; \"One\" &lt;&lt; 1;fs &lt;&lt; \"Two\" &lt;&lt; 2 &lt;&lt; \"&#125;\"; 为了从这些中读取，我们使用cv :: FileNode和cv :: FileNodeIterator数据结构。cv :: FileStorage类的[]运算符返回一个cv::FileNode数据类型。如果节点是顺序的，我们可以使用cv::FileNodeIterator遍历这些项目： 123456789FileNode n = fs[\"strings\"]; // Read string sequence - Get nodeif (n.type() != FileNode::SEQ)&#123; cerr &lt;&lt; \"strings is not a sequence! FAIL\" &lt;&lt; endl; return 1;&#125;FileNodeIterator it = n.begin(), it_end = n.end(); // Go through the nodefor (; it != it_end; ++it) cout &lt;&lt; (string)*it &lt;&lt; endl; 对于映射(maps)，您可以再次使用[]运算符来访问给定项目（或者&gt;&gt;操作符）： 123n = fs[\"Mapping\"]; // Read mappings from a sequencecout &lt;&lt; \"Two \" &lt;&lt; (int)(n[\"Two\"]) &lt;&lt; \"; \";cout &lt;&lt; \"One \" &lt;&lt; (int)(n[\"One\"]) &lt;&lt; endl &lt;&lt; endl; 5、读写你自己的数据结构。假设你有一个数据结构：123456789class MyData&#123;public: MyData() : A(0), X(0), id() &#123;&#125;public: // Data Members int A; double X; string id;&#125;; 通过在类内部和外部添加读取和写入函数，可以通过OpenCV I / O XML / YAML的接口对它进行序列化（就像OpenCV本身的数据结构一样）。 对于内部部分：12345678910void write(FileStorage&amp; fs) const //Write serialization for this class&#123; fs &lt;&lt; \"&#123;\" &lt;&lt; \"A\" &lt;&lt; A &lt;&lt; \"X\" &lt;&lt; X &lt;&lt; \"id\" &lt;&lt; id &lt;&lt; \"&#125;\";&#125;void read(const FileNode&amp; node) //Read serialization for this class&#123; A = (int)node[\"A\"]; X = (double)node[\"X\"]; id = (string)node[\"id\"];&#125; 然后你需要在类的外面添加下面的函数定义：1234567891011void write(FileStorage&amp; fs, const std::string&amp;, const MyData&amp; x)&#123;x.write(fs);&#125;void read(const FileNode&amp; node, MyData&amp; x, const MyData&amp; default_value = MyData())&#123;if(node.empty()) x = default_value;else x.read(node);&#125; 在这里你可以观察到，在read部分，我们定义了如果用户试图读取不存在的节点会发生什么。在这种情况下，我们只返回默认的初始化值，但是更详细的解决方案是返回一个对象ID的负值。一旦添加了这四个函数，就使用&gt;&gt;操作符进行写操作，使用&lt;&lt;操作符进行读操作： 123MyData m(1);fs &lt;&lt; \"MyData\" &lt;&lt; m; // your own data structuresfs[\"MyData\"] &gt;&gt; m; // Read your own structure_ 或者尝试阅读non-existing read：12fs[\"NonExisting\"] &gt;&gt; m; // Do not add a fs &lt;&lt; \"NonExisting\" &lt;&lt; m command for this to workcout &lt;&lt; endl &lt;&lt; \"NonExisting = \" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl; Result:大多数情况下，我们只是打印出定义的数字。在控制台的屏幕上，您可以看到：12345678910111213141516171819202122 Write Done. Reading: 100image1.jpg Awesomeness baboon.jpg Two 2; One 1 R = [1, 0, 0; 0, 1, 0; 0, 0, 1]T = [0; 0; 0]MyData =&#123; id = mydata1234, X = 3.14159, A = 97&#125;Attempt to read NonExisting (should initialize the data structure with its default).NonExisting =&#123; id = , X = 0, A = 0&#125;Tip: Open up output.xml with a text editor to see the serialized data. 尽管如此，在输出xml文件中可能会看到更有趣的内容： 12345678910111213141516171819202122232425 &lt;?xml version=\"1.0\"?&gt; &lt;opencv_storage&gt; &lt;iterationNr&gt;100&lt;/iterationNr&gt; &lt;strings&gt; image1.jpg Awesomeness baboon.jpg&lt;/strings&gt; &lt;Mapping&gt; &lt;One&gt;1&lt;/One&gt; &lt;Two&gt;2&lt;/Two&gt;&lt;/Mapping&gt; &lt;R type_id=\"opencv-matrix\"&gt; &lt;rows&gt;3&lt;/rows&gt; &lt;cols&gt;3&lt;/cols&gt; &lt;dt&gt;u&lt;/dt&gt; &lt;data&gt; 1 0 0 0 1 0 0 0 1&lt;/data&gt;&lt;/R&gt;&lt;T type_id=\"opencv-matrix\"&gt; &lt;rows&gt;3&lt;/rows&gt; &lt;cols&gt;1&lt;/cols&gt; &lt;dt&gt;d&lt;/dt&gt; &lt;data&gt; 0. 0. 0.&lt;/data&gt;&lt;/T&gt;&lt;MyData&gt; &lt;A&gt;97&lt;/A&gt; &lt;X&gt;3.1415926535897931e+000&lt;/X&gt; &lt;id&gt;mydata1234&lt;/id&gt;&lt;/MyData&gt;&lt;/opencv_storage&gt; Or the YAML file: 1234567891011121314151617181920212223 %YAML:1.0 iterationNr: 100 strings: - \"image1.jpg\" - Awesomeness - \"baboon.jpg\" Mapping: One: 1 Two: 2R: !!opencv-matrix rows: 3 cols: 3 dt: u data: [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]T: !!opencv-matrix rows: 3 cols: 1 dt: d data: [ 0., 0., 0. ]MyData: A: 97 X: 3.1415926535897931e+000 id: mydata1234 您可以在这里观看YouTube上的这个运行时实例。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-使用xml和yaml文件的文件输入和输出.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 离散傅里叶变换","slug":"【OpenCvTutorials3-1中文翻译】-离散傅里叶变换","date":"2018-02-16T08:10:10.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-离散傅里叶变换.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-离散傅里叶变换.html","excerpt":"Discrete Fourier Transform Goal:我们将为以下问题寻求答案： 什么是傅立叶变换以及为什么使用它？ 如何在OpenCV中做到这一点？ 函数的用法如：cv::copyMakeBorder（），cv::merge（），cv::dft（），cv :: getOptimalDFTSize（），cv :: log（）和 cv :: normalize（）。","text":"Discrete Fourier Transform Goal:我们将为以下问题寻求答案： 什么是傅立叶变换以及为什么使用它？ 如何在OpenCV中做到这一点？ 函数的用法如：cv::copyMakeBorder（），cv::merge（），cv::dft（），cv :: getOptimalDFTSize（），cv :: log（）和 cv :: normalize（）。 Source code你可以在这里或者是在samples/cpp/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.cpp获取代码。 以下是cv::dft（）的一个示例用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include \"opencv2/core/core.hpp\"#include \"opencv2/imgproc/imgproc.hpp\"#include \"opencv2/imgcodecs.hpp\"#include \"opencv2/highgui/highgui.hpp\"#include &lt;iostream&gt;using namespace cv;using namespace std;static void help(char* progName)&#123; cout &lt;&lt; endl &lt;&lt; \"This program demonstrated the use of the discrete Fourier transform (DFT). \" &lt;&lt; endl &lt;&lt; \"The dft of an image is taken and it's power spectrum is displayed.\" &lt;&lt; endl &lt;&lt; \"Usage:\" &lt;&lt; endl &lt;&lt; progName &lt;&lt; \" [image_name -- default ../data/lena.jpg] \" &lt;&lt; endl &lt;&lt; endl;&#125;int main(int argc, char ** argv)&#123; help(argv[0]); const char* filename = argc &gt;=2 ? argv[1] : \"../data/lena.jpg\"; Mat I = imread(filename, IMREAD_GRAYSCALE); if( I.empty()) return -1; Mat padded; //expand input image to optimal size int m = getOptimalDFTSize( I.rows ); int n = getOptimalDFTSize( I.cols ); // on the border add zero values copyMakeBorder(I, padded, 0, m - I.rows, 0, n - I.cols, BORDER_CONSTANT, Scalar::all(0)); Mat planes[] = &#123;Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F)&#125;; Mat complexI; merge(planes, 2, complexI); // Add to the expanded another plane with zeros dft(complexI, complexI); // this way the result may fit in the source matrix // compute the magnitude and switch to logarithmic scale // =&gt; log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2)) split(complexI, planes); // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I)) magnitude(planes[0], planes[1], planes[0]);// planes[0] = magnitude Mat magI = planes[0]; magI += Scalar::all(1); // switch to logarithmic scale log(magI, magI); // crop the spectrum, if it has an odd number of rows or columns magI = magI(Rect(0, 0, magI.cols &amp; -2, magI.rows &amp; -2)); // rearrange the quadrants of Fourier image so that the origin is at the image center int cx = magI.cols/2; int cy = magI.rows/2; Mat q0(magI, Rect(0, 0, cx, cy)); // Top-Left - Create a ROI per quadrant Mat q1(magI, Rect(cx, 0, cx, cy)); // Top-Right Mat q2(magI, Rect(0, cy, cx, cy)); // Bottom-Left Mat q3(magI, Rect(cx, cy, cx, cy)); // Bottom-Right Mat tmp; // swap quadrants (Top-Left with Bottom-Right) q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); // swap quadrant (Top-Right with Bottom-Left) q2.copyTo(q1); tmp.copyTo(q2); normalize(magI, magI, 0, 1, NORM_MINMAX); // Transform the matrix with float values into a // viewable image form (float between values 0 and 1). imshow(\"Input Image\" , I ); // Show the result imshow(\"spectrum magnitude\", magI); waitKey(); return 0;&#125; Explanation:傅里叶变换将图像分解为其正弦和余弦分量.也就是说，它会将图像从其空间域转换到其频域。 这个思想是任何函数都可以用无限的正弦函数和余弦函数的和来近似，傅立叶变换是一种如何做到这一点的方法。 在数学上二维图像傅里叶变换是： 这里f是空间域的图像值，F是频域的图像值。转换的结果是复数。通过a real image and a complex image或 通过幅度和相位图像来显示都是可能的。然而，在整个图像处理算法中，只有幅度图像是有趣的，因为这包含了我们需要的关于图像几何结构的所有信息。不过，你如果打算对这些形式的图像作一些修改，你就需要重新转换它，并且保留着两个 image。 在这个例子中，我将展示如何计算和显示傅里叶变换的幅度图像。数字图像是离散的。这意味着他们可能会从一个给定的域值中获得一个值。例如，在基本灰度级中，图像值通常在0到255之间，因此，傅里叶变换也需要是离散傅立叶变换（DFT）。每当需要从几何角度确定图像的结构时，您都会想要使用它。以下是要遵循的步骤（如果是灰度输入图像I）： 1、将图像展开至最佳尺寸。DFT的性能取决于图像大小。它往往是最快速度下的图像尺寸，它是数字2,3和5的倍数。因此，为了达到最佳性能，可以将边界值填充到获得具有这种特征的大小。cv::getOptimalDFTSize（） 返回这个最佳尺寸，我们可以使用 cv::copyMakeBorder()函数来扩展图像的边界： 1234Mat padded; //expand input image to optimal sizeint m = getOptimalDFTSize( I.rows );int n = getOptimalDFTSize( I.cols ); // on the border add zero pixelscopyMakeBorder(I, padded, 0, m - I.rows, 0, n - I.cols, BORDER_CONSTANT, Scalar::all(0)); 附加像素初始化为零。 2、为实部和虚部做好准备。傅立叶变换的结是复数。这意味着对于每个图像值，结果是两个图像值（每个组件一个）。而且，频域范围远大于其空间对应域。因此，我们通常至少以浮点格式存储这些数据。因此，我们会将我们的输入图像转换为此类型，并用另一个通道来扩展它以保存虚部( complex values )：123Mat planes[] = &#123;Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F)&#125;;Mat complexI;merge(planes, 2, complexI); // Add to the expanded another plane with zeros 3、进行离散傅里叶变换。可以进行就地计算（与输出相同的输入）：1dft(complexI, complexI); // this way the result may fit in the source matrix 4、将实部和虚部的值转换为数值。一个复数有一个实数（Re）和一个虚数（ Im）部分。 DFT的结果是复数。DFT的大小是： 用OpenCv代码实现：123split(complexI, planes); // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))magnitude(planes[0], planes[1], planes[0]);// planes[0] = magnitudeMat magI = planes[0]; 5、切换到对数比例。 （switch to logarithmic scale）事实证明，傅里叶系数的动态范围太大而不能显示在屏幕上。我们有一些很小和一些很高的变化值，我们不能这样观察。因此，高值将全部变成白点，而小值变成黑色。 要使用灰度值来进行可视化，我们可以将线性比例转换为对数： 用OpenCv代码实现：12magI += Scalar::all(1); // switch to logarithmic scalelog(magI, magI); 6、 裁切和重新排列。请记住，在第一步，我们扩大了图像。那么，是时候抛弃新引入的值了。为了可视化，我们还需要重新排列结果的象限，以便原点（0，0）与图像中心相对应。 1234567891011121314magI = magI(Rect(0, 0, magI.cols &amp; -2, magI.rows &amp; -2));int cx = magI.cols/2;int cy = magI.rows/2;Mat q0(magI, Rect(0, 0, cx, cy)); // Top-Left - Create a ROI per quadrantMat q1(magI, Rect(cx, 0, cx, cy)); // Top-RightMat q2(magI, Rect(0, cy, cx, cy)); // Bottom-LeftMat q3(magI, Rect(cx, cy, cx, cy)); // Bottom-RightMat tmp; // swap quadrants (Top-Left with Bottom-Right)q0.copyTo(tmp);q3.copyTo(q0);tmp.copyTo(q3);q1.copyTo(tmp); // swap quadrant (Top-Right with Bottom-Left)q2.copyTo(q1);tmp.copyTo(q2); 7、规范化。这是为了可视化目的而再次完成的。我们现在有这些幅度，但是这仍然超出了我们的图像显示范围（0到1）。我们使用cv::normalize（）函数将我们的值规范化到这个范围。 12normalize(magI, magI, 0, 1, NORM_MINMAX); // Transform the matrix with float values into a // viewable image form (float between values 0 and 1). Result：关于应用是确定图像中存在的几何取向。例如，让我们看看文本是否是水平的？Looking at some text you&#39;ll notice that the text lines sort of form also horizontal lines and the letters form sort of vertical lines. 在傅里叶变换的情况下，也可以看到文本片段的这两个主要组成部分。让我们使用这个水平和旋转文本的图像。 In case of the horizontal text（水平）: In case of a rotated text: 您可以看到，频域中最有影响的分量（幅度图像上最亮的点）遵循图像上物体的几何旋转。 由此我们可以计算偏移量并执行图像旋转以校正最终的对准。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-离散傅里叶变换.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"给默认不支持Add This的博客添加Add This分享服务","slug":"给博客添加Add This分享服务","date":"2018-02-16T07:00:26.000Z","updated":"2018-02-21T10:28:54.196Z","comments":true,"path":"posts/给默认不支持add-this的博客添加add-this分享服务.html","link":"","permalink":"http://little-rocket.cn/posts/给默认不支持add-this的博客添加add-this分享服务.html","excerpt":"为什么要用 Add This：颜值高啊：讲道理，这货的分享按钮看着是真的舒服； 支持自定义：可以自定义多种样式， 位置， 内容等。","text":"为什么要用 Add This：颜值高啊：讲道理，这货的分享按钮看着是真的舒服； 支持自定义：可以自定义多种样式， 位置， 内容等。 有自己网站的访问记录：这个，是真的很棒的了， 只要有访问你的网站，你将收到一封电子邮件的通知，对自己的网站热门情况了如指掌。比如我以前的博客，还时不时的收到邮件。 并不是所有的主题都默认支持Add This：是的，对于默认支持Add This的主题就不用多说了。在这里主要说说如何在不支持 AddThis 的Hexok 主题中加入AddThis分享： 具体步骤：到 AddThis 官网新建一个分享按钮， 并获取 安装代码： 将安装代码粘贴到 博客文件夹 /scaffolds/post.md 中：是的，就是这么简单粗暴。 目测 scaffolds文件夹中的3个文件是3个模板， 其中 post.md 就是你新建文章的时候， 新建的.md最开始的内容。 之后 使用1hexo n \"xxx\" 创建新文章的时候，就自动添加了Add This代码。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/给默认不支持add-this的博客添加add-this分享服务.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://little-rocket.cn/tags/博客/"}]},{"title":"自建ssr/ss科学上网服务器","slug":"自建ssr-ss科学上网服务器","date":"2018-02-15T13:51:12.000Z","updated":"2018-07-05T09:03:29.296Z","comments":true,"path":"posts/自建ssr-ss科学上网服务器.html","link":"","permalink":"http://little-rocket.cn/posts/自建ssr-ss科学上网服务器.html","excerpt":"VPS服务器甚至被墙了：是的， 服务器他喵的甚至被墙了，作为一只Google重度依赖者，表示无法科学上网，这日子没法过呀。在这里， 较为详细的总结一下搭建过程，已经服务商的选择。 具体搭建过程：","text":"VPS服务器甚至被墙了：是的， 服务器他喵的甚至被墙了，作为一只Google重度依赖者，表示无法科学上网，这日子没法过呀。在这里， 较为详细的总结一下搭建过程，已经服务商的选择。 具体搭建过程： 购买服务器：服务商的选择：首先， 选国外的不用说。然后，那个，服务器的地址，尽量别选日本，美国洛杉矶那些 “很火的地方”，因为那些地方能够买到可以使用的服务器的概率不大，，啊，你懂我意思吧。 我选择的是这个服务器商，可以点击链接注册；Vultr.com优点： 这个服务商最大的优点就是它的计费方式： 就是说， 它这个类似于网吧开机， 按照的是你创建服务器之后的时间来计费的， 注意是创建服务器， 不是服务器开机运行的时间。这样子的好处就是，若IP被墙了，只需要销毁掉之前那个重新开一个就是了。而且，可以在你不需要的时候，销毁掉你的服务器，这样也就停止扣费了。 支持 Alipay 也就是支付宝支付。 服务器的选购：首先是充 10美元： 然后直接点击右上方的那个 “+” 号，开始选择服务器：这里我选择的是 “Eueope” -&gt; “Frankfurt” -&gt; “Ubuntu 16.04 x64”然后几个选项，自己有需要就选吧，不选也可以。 点击 deploy Now就开始创建了 SSR服务的安装：本地工具： Git for win 安装过程：打开Git,运行：1$ ssh root@ip 输入密码，等待连接成功 安装SSR软件：1wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 然后，，惊了，设置是中文的，所以直接点击数字1， 开始安装 自己设置密码， 端口号默认就行。 加密选择 、协议插件、随意就好。我选择的是：caes-256-cfb + auth_sha1_v4 是否兼容原版， 按照自己需求选择 y/n。 混淆插件： 随意，我选择的是 plain. 然后是一些设备数，端口数限速什么的，，按照需求自己设置吧。 稍等片刻，安装完成。 查看SSR状态：输入：1bash ssr.sh 即可输入相应的选项，查看相关信息了。 安装SSR谷歌BBR加速：依次运行下面的命令：12345wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 重启服务器.SSR客户端下载：Github上的一个项目， 提供 linux， Windows， 安卓， MacOs客户端。地址：Github 参考链接： Alvin9999_Github 最后， 科学上网。。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/自建ssr-ss科学上网服务器.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://little-rocket.cn/tags/科学上网/"}]},{"title":"迁移自己搭建在虚拟主机上的hexo 博客","slug":"迁移自己搭建在虚拟主机上的hexo-博客","date":"2018-02-14T09:07:18.000Z","updated":"2018-02-22T08:47:23.964Z","comments":true,"path":"posts/迁移自己搭建在虚拟主机上的hexo-博客.html","link":"","permalink":"http://little-rocket.cn/posts/迁移自己搭建在虚拟主机上的hexo-博客.html","excerpt":"这事儿啥情况喃： 换了电脑，我他喵的也是惊了；环境迁移了2天，刚刚把自己的博客弄过来了，在这里总结一下： 博客环境： 阿里云最便宜的虚拟主机； Hexo 具体步骤：","text":"这事儿啥情况喃： 换了电脑，我他喵的也是惊了；环境迁移了2天，刚刚把自己的博客弄过来了，在这里总结一下： 博客环境： 阿里云最便宜的虚拟主机； Hexo 具体步骤： 准备博客目录： 下载安装 Node.js + Hexo + Git 说起来， 那个Git在国内貌似官网下载贼慢， 所以贴了一个Github的链接。 在一个新的博客文件夹中执行： 1hexo init 转移博客配置： 主题配置： 这里直接将 原博客文件夹中的 themes 文件夹复制过去即可； 文章转移： 直接将原博客文件夹中的 _posts中的文章复制过去即可； 站点配置： 将站点配置文件 _config.yml 复制过去； 插件转移： 这个，其实很容易忽略的， 因为，啊 就记得自己， 当时疯狂的 npm install了很多，这里有2个方法可以恢复以前安装的插件： 1、参考主题文档， 查找一些主题必备的插件；2、查看 文件package.json， 比如我的： 12345678910111213141516171819202122&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.5.0\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.2.0\", \"hexo-deployer-ftpsync\": \"^0.1.1\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-json-content\": \"^3.0.1\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.0\", \"hexo-renderer-marked\": \"^0.3.0\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.0\" &#125;&#125; 然后就可以看到自己安装了多少插件了。 将博客部署到虚拟主机： 安装ftpsync： 1npm install hexo-deployer-ftpsync --save 在站点配置文件中添加： 12345678910111213141516171819deploy: type: ftpsync host: bxu******.my3w.com //主机地址 user: bxu****** //用户名 pass: ********* //密码 remote: /htdocs //目录，应该所有阿里云虚拟主机的网站内容目录都是这个，不是根目录 / port: xx ignore: [‘.DS_Store’,’/logreport’,’/zhuye.html’,’/report’,’/.svn’,’/.google5848b58bec5a3bf7.html’] //这里表示的是上传的时候忽略这些文件。 connections: verbose: true``` * 生成发布内容：```C++hexo g 发布内容： 1hexo d 补充：补充1、Sublime Text3 Markdown环境的搭建：其实之前用VS Code感觉还不错， 但是想到自己电脑都换了，那干脆去试试其他的环境吧，然后就想到了Sublime Text3；下载安装等，，不废话了，直接说插件： Package Control： 包管理； Markdown Editing： 方便MarkDown管理的； MarkDown Preview： 预览； 关于将 MarkDown 转换为 PDF的方法： 利用 MarkDown Preview 在浏览器预览， 然后直接 打印， 之后就有pdf了； 关于在旁边及时预览的插件： 有是有， 但是有点， 额 ， 不太好看， 嗯。而且， 不流畅，。说起来， 写了那么多md了， 自己写成啥样心里没电ACD数吗。。 补充2、博客页面加载条的实现：参考链接为Hexo博客添加顶部加载条 补充3、博客文章添加作者信息与版权： 在博客根目录下新建文件夹：scripts: 进入该目录， 新建AddTail.js文件， 内容： 1234567891011121314151617181920212223242526272829303132333435// Filename: AddTail.js// Author: Colin// Date: 2016/06/02// Based on the script by KUANG Qi: http://kuangqi.me/tricks/append-a-copyright-info-after-every-post/// Add a tail to every post from tail.md// Great for adding copyright infovar fs = require('fs');hexo.extend.filter.register('before_post_render', function(data)&#123; if(data.copyright == false) return data; // Add seperate line data.content += '\\n___\\n'; // Try to read tail.md try &#123; var file_content = fs.readFileSync('tail.md'); if(file_content &amp;&amp; data.content.length &gt; 50) &#123; data.content += file_content; &#125; &#125; catch (err) &#123; if (err.code !== 'ENOENT') throw err; // No process for ENOENT error &#125; // 添加具体文章链接, 不需要去掉即可 var permalink = '\\n本文链接：' + data.permalink; data.content += permalink; return data;&#125;); 进入博客根目录： 新建文件 tail.md写下自己的内容， 比如我的：1&lt;a rel=\"license\" href=\"http://creativecommons.org/licenses/by/2.5/cn/\"&gt;&lt;img alt=\"知识共享许可协议\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by/2.5/cn/88x31.png\" /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=\"license\" href=\"http://creativecommons.org/licenses/by/2.5/cn/\"&gt;知识共享署名 2.5 中国大陆许可协议&lt;/a&gt;进行许可。欢迎转载，但是请注明来自[little-rocket-blog](http://little-rocket.cn/)，并保证转载后文章的完整性。本人保留所有版权相关权利。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/迁移自己搭建在虚拟主机上的hexo-博客.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://little-rocket.cn/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-14T08:28:05.122Z","updated":"2018-03-26T15:19:13.425Z","comments":true,"path":"posts/hello-world.html","link":"","permalink":"http://little-rocket.cn/posts/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new postRun server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/hello-world.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://little-rocket.cn/categories/Hexo/"}],"tags":[]},{"title":"将搭建在阿里云虚拟主机的博客配置为HTTPS访问","slug":"将搭建在阿里云虚拟主机的博客配置为HTTPS访问","date":"2018-02-11T03:37:44.000Z","updated":"2018-02-21T10:28:54.194Z","comments":true,"path":"posts/将搭建在阿里云虚拟主机的博客配置为https访问.html","link":"","permalink":"http://little-rocket.cn/posts/将搭建在阿里云虚拟主机的博客配置为https访问.html","excerpt":"HTTPS的优缺点： 详情可以移步某乎 博客环境： 阿里云共享虚拟主机普惠版 Hexo + hexo-theme-icarus 具体过程：","text":"HTTPS的优缺点： 详情可以移步某乎 博客环境： 阿里云共享虚拟主机普惠版 Hexo + hexo-theme-icarus 具体过程： 1、购买阿里云免费型DVSSL证书 注意这个只能绑定一个域名，因此我这里购买了2个。 2、补全证书注意这里，如果是在阿里云购买的域名，可以直接勾选那个“勾勾”DNS验证就可以了。保证自己的信息正确并且足够详细之后，就可以提交审核了。大概10分钟作用就审核完成了。 之前我弄了那个证书绑定的域名没有www，结果不得行，后面又提交了个带有www的域名。 3、下载证书后面两个并没有用到， key结尾的是私钥， pem结尾的是公钥。 4、CDN管理 注意： 这里必须选择80端口； 类型为 IP ； 源站 IP 为主机IP 注意： 选择证书： 自定义上传， 然后将自己购买的证书的名字COPY进去； 公钥: 就是上面的那个xxxx（数字）.pem里面的内容； 私钥：xxxx（数字）.key里面的内容； 5、CHAME 设置：最后一步，设置DNS解析， 添加域名之后，应该会有一个CHAME值，只需要将它添加到DNS解析即可。如下图最后2个： 这个地方只需要修改即可： 解析列表里面应该有2个 A 解析， 一个带 www一个不带； 将带www的那个改为 CHAME ,记录值改为“CHAME”值。 6、注意： https访问的域名是带www的因此域名绑定的时候，要选择带有 www的域名。 等待一小会，刷新一下自己的网站，就可以看到是https了。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/将搭建在阿里云虚拟主机的博客配置为https访问.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://little-rocket.cn/tags/博客/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 随机数生成器以及OpenCv中的文本","slug":"【OpenCvTutorials3-1中文翻译】-随机数生成器以及OpenCv中的文本","date":"2018-02-10T11:49:08.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-随机数生成器以及opencv中的文本.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-随机数生成器以及opencv中的文本.html","excerpt":"Random generator and text with OpenCVGoal在本教程中，您将学习： 使用随机数生成器类（cv::RNG）以及如何从统一分布中获得一个随机数。 使用函数cv::putText在OpenCV窗口上显示文本","text":"Random generator and text with OpenCVGoal在本教程中，您将学习： 使用随机数生成器类（cv::RNG）以及如何从统一分布中获得一个随机数。 使用函数cv::putText在OpenCV窗口上显示文本 Code 在前面的教程（Basic Drawing）中，我们绘制了不同的几何图形，给出了输入参数，如坐标（以cv :: Point的形式），颜色，厚度等等。您可能已经注意到，我们给出的是这些参数的具体值。 在本教程中我们打算使用随机值作为绘图函数的参数。此外，我们打算用大量的几何图形填充我们的图像。由于我们将以随机方式初始化它们，所以这个过程将会通过循环来自动的。 此代码位于您的OpenCV的sample文件夹中。 否则，你可以从这里得到它。 Explanation1、我们先看看main函数。 我们观察到，我们所做的第一件事是创建一个随机数生成器对象（RNG）：1RNG rng( 0xFFFFFFFF ); RNG实现一个随机数字发生器。 在这个例子中，rng是一个用值0xFFFFFFFF初始化的RNG元素 2、然后我们创建一个初始化为零的矩阵（这意味着它将显示为黑色），并且指定其高度，宽度和类型：12Mat image = Mat::zeros( window_height, window_width, CV_8UC3 );imshow( window_name, image ); 3、然后我们开始疯狂的作图， 看过代码之后， 可以看到它主要分为8个部分， 并且被定义为以下函数：123456789101112131415c = Drawing_Random_Lines(image, window_name, rng);if( c != 0 ) return 0;c = Drawing_Random_Rectangles(image, window_name, rng);if( c != 0 ) return 0;c = Drawing_Random_Ellipses( image, window_name, rng );if( c != 0 ) return 0;c = Drawing_Random_Polylines( image, window_name, rng );if( c != 0 ) return 0;c = Drawing_Random_Filled_Polygons( image, window_name, rng );if( c != 0 ) return 0;c = Drawing_Random_Circles( image, window_name, rng );if( c != 0 ) return 0;c = Displaying_Random_Text( image, window_name, rng );if( c != 0 ) return 0;c = Displaying_Big_End( image, window_name, rng ); 所有这些功能都遵循相同的模式，所以我们只分析其中的一个，因为所有的说明几乎都是一样的。4、研究一下函数 Drawing_Random_Lines ：1234567891011121314151617int Drawing_Random_Lines( Mat image, char* window_name, RNG rng )&#123; int lineType = 8; Point pt1, pt2; for( int i = 0; i &lt; NUMBER; i++ ) &#123; pt1.x = rng.uniform( x_1, x_2 ); pt1.y = rng.uniform( y_1, y_2 ); pt2.x = rng.uniform( x_1, x_2 ); pt2.y = rng.uniform( y_1, y_2 ); line( image, pt1, pt2, randomColor(rng), rng.uniform(1, 10), 8 ); imshow( window_name, image ); if( waitKey( DELAY ) &gt;= 0 ) &#123; return -1; &#125; &#125; return 0;&#125; 我们可以知道： for循环将重复 NUMBER 次。 由于函数cv::line在这个循环中，这意味着将会生成 NUMBER条line。 线的端点是pt1和pt2提供的。 对于pt1我们可以看到： 12pt1.x = rng.uniform( x_1, x_2 );pt1.y = rng.uniform( y_1, y_2 ); 我们知道rng是一个随机数字生成器对象。 在上面的代码中，我们调用 rng.uniform（a，b）。 这会在值 a 和 b 之间产生一个随机均匀分布（包括 a，不包括 *b）。 从上面的解释中，我们推断极值pt1和pt2将是随机值，所以线的位置将是相当不可预测的，给出了一个很好的视觉效果（查看下面的Result部分）。 另一方面，我们注意到在cv::line参数中，对于颜色我们输入：1randomColor(rng) 我们来看看函数的实现：12345static Scalar randomColor( RNG&amp; rng ) &#123; int icolor = (unsigned) rng; return Scalar( icolor&amp;255, (icolor&gt;&gt;8)&amp;255, (icolor&gt;&gt;16)&amp;255 ); &#125; 我们可以看到，返回值是一个具有3个随机初始化值的标量，用作线颜色的R，G和B参数。 因此，线条的颜色也是随机的！ 5、上面的解释适用于生成圆，椭圆，多边形等其他函数。中心和顶点等参数也是随机生成的。 6、在完成之前，我们还应该看看函数 Display_Random_Text 和 Displaying_Big_End，因为它们都有一些有趣的特性： 7、Display_Random_Text12345678910111213141516int Displaying_Random_Text( Mat image, char* window_name, RNG rng )&#123; int lineType = 8; for ( int i = 1; i &lt; NUMBER; i++ ) &#123; Point org; org.x = rng.uniform(x_1, x_2); org.y = rng.uniform(y_1, y_2); putText( image, \"Testing text rendering\", org, rng.uniform(0,8), rng.uniform(0,100)*0.05+0.1, randomColor(rng), rng.uniform(1, 10), lineType); imshow( window_name, image ); if( waitKey(DELAY) &gt;= 0 ) &#123; return -1; &#125; &#125; return 0;&#125; 一切看起来很熟悉，但表达的：12putText( image, \"Testing text rendering\", org, rng.uniform(0,8), rng.uniform(0,100)*0.05+0.1, randomColor(rng), rng.uniform(1, 10), lineType); 那么，在我们的例子中函数cv::putText做了什么？ * 在图像中绘制文本 “Testing text rendering” * 文本的左下角将位于 `Point org`. * 字体类型(font type)是一个随机的整数值，范围：[0,8) * 字体的尺度用表达式 `rng.uniform（0,100）x0.05 + 0.1`（表示它的范围是：[0.1,5.1)） * 文本颜色是随机的（由 `randomColor（rng）`表示） * 文本厚度在1到10之间，由rng.uniform（1,10）指定。 因此，我们将在随机位置得到（与其他绘图功能类似的）NUMBER个文本。 8、 Displaying_Big_End1234567891011121314151617int Displaying_Big_End( Mat image, char* window_name, RNG rng )&#123; Size textsize = getTextSize(\"OpenCV forever!\", FONT_HERSHEY_COMPLEX, 3, 5, 0); Point org((window_width - textsize.width)/2, (window_height - textsize.height)/2); int lineType = 8; Mat image2; for( int i = 0; i &lt; 255; i += 2 ) &#123; image2 = image - Scalar::all(i); putText( image2, \"OpenCV forever!\", org, FONT_HERSHEY_COMPLEX, 3, Scalar(i, i, 255), 5, lineType ); imshow( window_name, image2 ); if( waitKey(DELAY) &gt;= 0 ) &#123; return -1; &#125; &#125; return 0;&#125; 除了函数getTextSize（获取参数文本的大小），我们可以观察到的新操作是在for循环内：1image2 = image - Scalar::all(i) 因此， image2 是 image 和 Scalar::all（i）的减法运算， 实际上，这里发生的事情是：image2的每一个像素将是 image的每一个像素减去 i的结果（请记住，对于每个像素，我们考虑三个值：R，G和B，因此每个像素都将受到影响）。 另外请记住，减法运算总是在内部执行一个饱和运算，这意味着得到的结果总是在允许的范围内（对我们的例子来说，没有负数，都在0到255之间）。 Result正如你在代码部分看到的，程序将顺序执行不同的绘图功能，这将产生： 1、首先随机设置的 NUMBER lines 将出现在屏幕上，如下图所示： 2、然后，一组新的图形，这些时间矩形将随之而来。3、现在会出现一些椭圆，每个椭圆都是随机的位置，大小，厚度和弧长： 4、现在，03段的折线将出现在屏幕上，也是随机配置。 5、填充的多边形（在这个例子中是三角形）随之而来。6、最后要显示的一个几何图形：圆圈！ 7、紧接着最后，文本“Testing Text Rendering”将出现在各种字体，大小，颜色和位置。 8、而大的结局（顺便也表达了一个大真理）： 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-随机数生成器以及opencv中的文本.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"每天掌握一点Vs2013快捷键(持续更新)","slug":"每天掌握一点Vs2013快捷键-持续更新","date":"2018-02-09T08:34:43.000Z","updated":"2018-03-17T09:25:07.800Z","comments":true,"path":"posts/每天掌握一点vs2013快捷键-持续更新.html","link":"","permalink":"http://little-rocket.cn/posts/每天掌握一点vs2013快捷键-持续更新.html","excerpt":"一切为了更加高效的 Coding某日在油桶上看到某大神Coding，全程几乎不用鼠标，深受感触。故想从今天开始，学习Vs2013 的快捷键。每天学习几点，日积月累，相信我能早日脱离鼠标的“束缚”，嗯就这样。","text":"一切为了更加高效的 Coding某日在油桶上看到某大神Coding，全程几乎不用鼠标，深受感触。故想从今天开始，学习Vs2013 的快捷键。每天学习几点，日积月累，相信我能早日脱离鼠标的“束缚”，嗯就这样。 / ————————————-2018 2 10 日 更 新—————————————————– / 命令 快捷键 查找上一个 Shift+F3 查找上一个选定项 Ctrl+Shift+F3 转到 Ctrl+G 查找下一个 F3 转到声明 Ctrl+F12 / ————————————-2018 2 9 日 更 新—————————————————– / 命令 快捷键 循环应用剪贴板中的复制项 Ctrl+Shift+V 查找所有引用 Shift+F12 在文件中查找 Ctrl+Shift+F 查找下一个 F3 查找下一个选定项 Ctrl+F3 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/每天掌握一点vs2013快捷键-持续更新.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"持续更新","slug":"持续更新","permalink":"http://little-rocket.cn/tags/持续更新/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 基本绘图","slug":"【OpenCvTutorials3-1中文翻译】-基本绘图","date":"2018-02-06T09:15:15.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-基本绘图.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-基本绘图.html","excerpt":"Basic Drawing Golas:在本教程中，您将学习如何： 使用cv::Point在图像中定义2D点。 使用cv::Scalar和它为什么是有用的 使用OpenCV函数cv::line绘制一条线 使用OpenCV函数cv::ellipse绘制一个椭圆 使用OpenCV函数cv::rectangle绘制一个矩形 使用OpenCV函数cv::circle绘制一个圆 使用OpenCV函数cv::fillPoly绘制一个填充的多边形","text":"Basic Drawing Golas:在本教程中，您将学习如何： 使用cv::Point在图像中定义2D点。 使用cv::Scalar和它为什么是有用的 使用OpenCV函数cv::line绘制一条线 使用OpenCV函数cv::ellipse绘制一个椭圆 使用OpenCV函数cv::rectangle绘制一个矩形 使用OpenCV函数cv::circle绘制一个圆 使用OpenCV函数cv::fillPoly绘制一个填充的多边形 OpenCV Theory对于本教程，我们将大量使用两个结构:cv::Point和cv::Scalar Point它表示一个2D点，由它的图像坐标x、y指定:123Point pt;pt.x = 10;pt.y = 8; 或者1Point pt = Point(10, 8); Scalar 代表一个4元素的向量。 标量类型广泛用于OpenCV传递像素值。 在本教程中，我们将广泛使用它来表示BGR颜色值（3个参数）。 如果不打算使用最后一个参数，则没有必要定义它。 让我们看一个例子，如果我们需要一个颜色参数，我们设定：1Scalar( a, b, c ) 我们将定义BGR颜色，例如：蓝色= a，绿色= b和红色= c Code此代码位于您的OpenCV示例文件夹中。 此外，你可以从这里找到它。 Explanation1、既然我们打算画两个例子（一个atom和一个rook），nam我们必须创建02个图像和两个窗口来显示它们。 1234char atom_window[] = \"Drawing 1: Atom\";char rook_window[] = \"Drawing 2: Rook\";Mat atom_image = Mat::zeros( w, w, CV_8UC3 );Mat rook_image = Mat::zeros( w, w, CV_8UC3 ); 2、我们创建了绘制不同几何形状的函数。 例如，要绘制Atom我们使用MyEllipse和MyFilledCircle： 12345MyEllipse( atom_image, 90 );MyEllipse( atom_image, 0 );MyEllipse( atom_image, 45 );MyEllipse( atom_image, -45 );MyFilledCircle( atom_image, Point( w/2.0, w/2.0) ); 3、为了画出我们的rook的我们使用 MyLine，rectangle和MyPolygon：1234567891011MyPolygon( rook_image );rectangle( rook_image, Point( 0, 7*w/8.0 ), Point( w, w), Scalar( 0, 255, 255 ), -1, 8 );MyLine( rook_image, Point( 0, 15*w/16 ), Point( w, 15*w/16 ) );MyLine( rook_image, Point( w/4, 7*w/8 ), Point( w/4, w ) );MyLine( rook_image, Point( w/2, 7*w/8 ), Point( w/2, w ) );MyLine( rook_image, Point( 3*w/4, 7*w/8 ), Point( 3*w/4, w ) ); 4、让我们来看看每个函数里面的内容： MyLine123456789void MyLine( Mat img, Point start, Point end )&#123; int thickness = 2; int lineType = 8; line( img, start, end, Scalar( 0, 0, 0 ), thickness, lineType );&#125; 正如我们所看到的，MyLine只是调用函数cv :: line，它执行以下操作： 从start点到end点画一条线 这个直线显示在图像img中 线的颜色由Scalar( 0, 0, 0)定义，这是与黑色对应的RGB值 线的厚度被设定为thickness（在这种情况下为2） 这条线是一个8连接的（lineType = 8） MyEllipse1234567891011121314void MyEllipse( Mat img, double angle )&#123; int thickness = 2; int lineType = 8; ellipse( img, Point( w/2.0, w/2.0 ), Size( w/4.0, w/16.0 ), angle, 0, 360, Scalar( 255, 0, 0 ), thickness, lineType );&#125; 从上面的代码，我们可以观察到函数cv::ellipse绘制一个椭圆，使得： 椭圆显示在图像img中 椭圆中心位于点 （w / 2.0，w / 2.0） 中，并被包围在一个大小为 （w / 4.0，w / 16.0） 的框中 椭圆旋转angle角度 椭圆在0和360度之间延伸一个弧 图形的颜色将是Scalar（255，0，0），这意味着RGB值为蓝色。 椭圆的thickness是2。 MyFilledCircle1234567891011void MyFilledCircle( Mat img, Point center )&#123; int thickness = -1; int lineType = 8; circle( img, center, w/32.0, Scalar( 0, 0, 255 ), thickness, lineType );&#125; 类似于椭圆函数，我们可以观察到circle作为参数接收：将显示圆圈的图像（img） 圆的中心表示为点center 圆的半径：w / 32.0 圆的颜色：Scalar（0，0，255），意思是BGR中的红色 由于厚度 (thickness) = -1，圆圈将被填充。 MyPolygon12345678910111213141516171819202122232425262728293031323334void MyPolygon( Mat img )&#123; int lineType = 8; /* Create some points */ Point rook_points[1][20]; rook_points[0][0] = Point( w/4.0, 7*w/8.0 ); rook_points[0][1] = Point( 3*w/4.0, 7*w/8.0 ); rook_points[0][2] = Point( 3*w/4.0, 13*w/16.0 ); rook_points[0][3] = Point( 11*w/16.0, 13*w/16.0 ); rook_points[0][4] = Point( 19*w/32.0, 3*w/8.0 ); rook_points[0][5] = Point( 3*w/4.0, 3*w/8.0 ); rook_points[0][6] = Point( 3*w/4.0, w/8.0 ); rook_points[0][7] = Point( 26*w/40.0, w/8.0 ); rook_points[0][8] = Point( 26*w/40.0, w/4.0 ); rook_points[0][9] = Point( 22*w/40.0, w/4.0 ); rook_points[0][10] = Point( 22*w/40.0, w/8.0 ); rook_points[0][11] = Point( 18*w/40.0, w/8.0 ); rook_points[0][12] = Point( 18*w/40.0, w/4.0 ); rook_points[0][13] = Point( 14*w/40.0, w/4.0 ); rook_points[0][14] = Point( 14*w/40.0, w/8.0 ); rook_points[0][15] = Point( w/4.0, w/8.0 ); rook_points[0][16] = Point( w/4.0, 3*w/8.0 ); rook_points[0][17] = Point( 13*w/32.0, 3*w/8.0 ); rook_points[0][18] = Point( 5*w/16.0, 13*w/16.0 ); rook_points[0][19] = Point( w/4.0, 13*w/16.0) ; const Point* ppt[1] = &#123; rook_points[0] &#125;; int npt[] = &#123; 20 &#125;; fillPoly( img, ppt, npt, 1, Scalar( 255, 255, 255 ), lineType );&#125; 要绘制一个填充的多边形，我们使用函数cv::fillPoly。 我们注意到： 多边形将在 img 上绘制 多边形的顶点是 ppt中的点的集合 要绘制的顶点总数是 npt 要绘制的多边形数量只有 1个 多边形的颜色由 Scalar（255,255,255）定义，它是白色的BGR值 rectangle12345rectangle( rook_image, Point( 0, 7*w/8.0 ), Point( w, w), Scalar( 0, 255, 255 ), -1, 8 ); 最后我们有cv::rectangle函数（我们没有为这个人创建一个特殊的函数）。 我们注意到： 矩形将在 rook_image上绘制 Point（0，7 * w / 8.0） 和 Point（w，w）定义矩形的两个相对顶点 矩形的颜色由Scalar（0,255,255）给出，它是黄色的BGR值 由于厚度值由 - 1 给出，矩形将被填充 Result编译和运行你的程序应该给你这样的结果： 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-基本绘图.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 改变图像的对比度和亮度！","slug":"【OpenCvTutorials3-1中文翻译】-改变图像的对比度和亮度！","date":"2018-02-05T09:19:16.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-改变图像的对比度和亮度！.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-改变图像的对比度和亮度！.html","excerpt":"Changing the contrast and brightness of an image!Goal在本教程中，您将学习如何： 访问像素值 用零初始化一个矩阵 了解cv::saturate_cast做什么以及为什么它很有用 获取有关像素变换的一些很酷的信息","text":"Changing the contrast and brightness of an image!Goal在本教程中，您将学习如何： 访问像素值 用零初始化一个矩阵 了解cv::saturate_cast做什么以及为什么它很有用 获取有关像素变换的一些很酷的信息 Theory Note:下面的解释属于计算机视觉：理查德Szeliski算法和应用程序 图像处理 一般的图像处理操作符是一个获取一个或多个输入图像并产生输出图像的功能。 图像转换可以被看作是： 点运算符（像素变换） 邻域操作 像素变换 在这种图像处理变换中，每个输出像素的值仅取决于相应的输入像素值（可能还有一些全局收集的信息或参数）。 这些例子的操作包括亮度和对比度调整以及颜色校正和变换。 亮度和对比度调整 两个常用的点过程是乘上和加上一个常量： 译者注：原文： “Two commonly used point processes are multiplication and &gt;addition with a constant:”不好翻译， 可以结合下面的公式理解 参数 α &gt; 0β You can think of f(x)g(x)： where i j Code以下代码执行运算：12345678910111213141516171819202122232425262728#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;double alpha; /*&lt; Simple contrast control */int beta; /*&lt; Simple brightness control */int main( int argc, char** argv )&#123; Mat image = imread( argv[1] ); Mat new_image = Mat::zeros( image.size(), image.type() ); std::cout&lt;&lt;\" Basic Linear Transforms \"&lt;&lt;std::endl; std::cout&lt;&lt;\"-------------------------\"&lt;&lt;std::endl; std::cout&lt;&lt;\"* Enter the alpha value [1.0-3.0]: \";std::cin&gt;&gt;alpha; std::cout&lt;&lt;\"* Enter the beta value [0-100]: \"; std::cin&gt;&gt;beta; for( int y = 0; y &lt; image.rows; y++ ) &#123; for( int x = 0; x &lt; image.cols; x++ ) &#123; for( int c = 0; c &lt; 3; c++ ) &#123; new_image.at&lt;Vec3b&gt;(y,x)[c] = saturate_cast&lt;uchar&gt;( alpha*( image.at&lt;Vec3b&gt;(y,x)[c] ) + beta ); &#125; &#125; &#125; namedWindow(\"Original Image\", 1); namedWindow(\"New Image\", 1); imshow(\"Original Image\", image); imshow(\"New Image\", new_image); waitKey(); return 0;&#125; 说明1、 我们首先创建参数来保存α β12double alpha;int beta; 2、我们使用cv::imread加载图像，并将其保存在Mat对象中： 1Mat image = imread( argv[1] ); 3、现在，由于我们将对这个图像进行一些转换，我们需要一个新的Mat对象来存储它。 另外，我们希望这具有以下特点： * 初始像素值等于零 * 与原始图像大小和类型相同 1Mat new_image = Mat::zeros( image.size(), image.type() ); 我们观察到cv::Mat::zeros返回一个基于image.size（）和image.type（）的Matlab风格的零初始化器. 4、现在，执行操作 g（i，j）=α·f（i，j）+β 12345678for( int y = 0; y &lt; image.rows; y++ ) &#123; for( int x = 0; x &lt; image.cols; x++ ) &#123; for( int c = 0; c &lt; 3; c++ ) &#123; new_image.at&lt;Vec3b&gt;(y,x)[c] = saturate_cast&lt;uchar&gt;( alpha*( image.at&lt;Vec3b&gt;(y,x)[c] ) + beta ); &#125; &#125;&#125; 注意以下几点： * 要访问图像中的每个像素，我们使用这个语法：image.at &lt;Vec3b&gt;（y，x）[c]其中y是行，x是列，c是R，G或B（0,1或2）。 * 由于运算α⋅p（i，j）+βα⋅p（i，j）+β 译者注：原文： “Since the operation α⋅p(i,j)+βα⋅p(i,j)+βα”后面多了个α。 最后，我们创建窗口，并显示图像。12345namedWindow(\"Original Image\", 1);namedWindow(\"New Image\", 1);imshow(\"Original Image\", image);imshow(\"New Image\", new_image);waitKey(0); Note:我们可以简单地使用这个命令, 而不是使用for循环来访问每个像素：1image.convertTo(new_image, -1, alpha, beta); 其中cv::Mat::convertTo将有效地执行 new_image = a image + beta *。 不过，我们想告诉你如何访问每个像素。 在任何情况下，这两种方法给出了相同的结果，但convertTo更优化，工作速度更快。 Result Running our code and using α=2.2 β=50 12345$ ./BasicLinearTransforms lena.jpgBasic Linear Transforms-------------------------* Enter the alpha value [1.0-3.0]: 2.2* Enter the beta value [0-100]: 50 We get this: 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-改变图像的对比度和亮度！.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 使用OpenCV添加（混合）两个图像","slug":"【OpenCvTutorials3-1中文翻译】-使用OpenCV添加（混合）两个图像","date":"2018-02-05T07:50:32.000Z","updated":"2018-07-15T13:23:40.681Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-使用opencv添加（混合）两个图像.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-使用opencv添加（混合）两个图像.html","excerpt":"Adding (blending) two images using OpenCVGoal在本教程中，您将学习： 什么是线性混合以及为什么它是有用的; 如何使用cv::addWeighted添加两个图像","text":"Adding (blending) two images using OpenCVGoal在本教程中，您将学习： 什么是线性混合以及为什么它是有用的; 如何使用cv::addWeighted添加两个图像 原理Note:下面的解释属于计算机视觉：理查德Szeliski算法和应用程序 从我们以前的教程中，我们已经知道一些像素运算符。 一个有趣的二元（双输入）算子是线性混合算子： 通过改变 α0 → 1 Code像往常一样，在不那么冗长的解释之后，我们来看代码： 123456789101112131415161718192021222324#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;int main( int argc, char** argv )&#123; double alpha = 0.5; double beta; double input; Mat src1, src2, dst; std::cout&lt;&lt;\" Simple Linear Blender \"&lt;&lt;std::endl; std::cout&lt;&lt;\"-----------------------\"&lt;&lt;std::endl; std::cout&lt;&lt;\"* Enter alpha [0-1]: \"; std::cin&gt;&gt;input; if( input &gt;= 0.0 &amp;&amp; input &lt;= 1.0 ) &#123; alpha = input; &#125; src1 = imread(\"../../images/LinuxLogo.jpg\"); src2 = imread(\"../../images/WindowsLogo.jpg\"); if( !src1.data ) &#123; printf(\"Error loading src1 \\n\"); return -1; &#125; if( !src2.data ) &#123; printf(\"Error loading src2 \\n\"); return -1; &#125; namedWindow(\"Linear Blend\", 1); beta = ( 1.0 - alpha ); addWeighted( src1, alpha, src2, beta, 0.0, dst); imshow( \"Linear Blend\", dst ); waitKey(0); return 0;&#125; 解释1、由于我们要执行： 我们需要两个源图像: 12src1 = imread(\"../../images/LinuxLogo.jpg\");src2 = imread(\"../../images/WindowsLogo.jpg\"); warning由于我们添加了src1和src2，它们必须具有相同的大小（宽度和高度）和类型。 2、现在我们需要生成g（x）图像。 为此，可以非常方便使用add_weighted：addWeighted函数：因为cv :: addWeighted产生： 在这种情况下，gamma是参数0.0 3、创建窗口，显示图像并等待用户结束程序。 Result 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-使用opencv添加（混合）两个图像.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 操作图像","slug":"【OpenCvTutorials3-1中文翻译】- 操作图像","date":"2018-02-05T06:07:34.000Z","updated":"2018-07-15T13:23:40.681Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-操作图像.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-操作图像.html","excerpt":"Operations with images输入输出图片从文件加载图像：1Mat img = imread(filename) 如果您读取一个jpg文件，默认情况下会创建一个3通道图像。 如果您需要灰度图像，请使用：1Mat img = imread(filename, 0);","text":"Operations with images输入输出图片从文件加载图像：1Mat img = imread(filename) 如果您读取一个jpg文件，默认情况下会创建一个3通道图像。 如果您需要灰度图像，请使用：1Mat img = imread(filename, 0); 注意：文件格式由其内容决定（前几个字节）将图像保存到文件中： 1imwrite(filename, img); 注意： 该文件的格式是由其扩展名决定的。使用imdecode和imencode是从内存读/写图像而不是文件。 图像的基本操作访问像素强度值为了获得像素强度值，您必须知道图像的类型和通道的数量。 以下是单通道灰度图像（类型8UC1）和像素坐标x和y的示例：1Scalar intensity = img.at&lt;uchar&gt;(y, x); intensity.val [0]包含从0到255的值。请注意x和y的排序。因为在OpenCV中，图像由与矩阵相同的结构表示，所以我们在两种情况下都使用相同的约定 - 基于0的行索引（或y坐标）先出现，然后是基于0的列索引（或x坐标)。 另外，您可以使用以下表示法：1Scalar intensity = img.at&lt;uchar&gt;(Point(x, y)); 现在让我们考虑一个BGR颜色排序的3通道图像（imread返回的默认格式）：1234Vec3b intensity = img.at&lt;Vec3b&gt;(y, x);uchar blue = intensity.val[0];uchar green = intensity.val[1];uchar red = intensity.val[2]; 您可以对浮点图像使用相同的方法（例如，可以通过在3通道图像上运行Sobel来获得这样的图像）： 1234Vec3f intensity = img.at&lt;Vec3f&gt;(y, x);float blue = intensity.val[0];float green = intensity.val[1];float red = intensity.val[2]; 可以使用相同的方法来改变像素强度：1img.at&lt;uchar&gt;(y, x) = 128; 在OpenCV中有函数，特别是来自calib3d模块的函数，比如projectPoints，它以Mat的形式获取一个2D或3D点的数组。 矩阵应该只包含一列，每一行对应一个点，矩阵类型应相应为32FC2或32FC3。 这样的矩阵可以很容易地从std::vector构造出来：123vector&lt;Point2f&gt; points;//... fill the array填充数组Mat pointsMat = Mat(points); 可以使用相同的方法Mat::at在这个矩阵中访问一个点：1Point2f point = pointsMat.at&lt;Point2f&gt;(i, 0); 内存管理和引用计数Mat是一种保持矩阵/图像特征（行和列号，数据类型等）和指向数据的指针的结构。 所以没有任何东西阻止我们有几个Mat实例对应于相同的数据。 一个Mat保留一个引用计数，告诉数据是否在Mat的特定实例被销毁时被释放。 以下是创建两个矩阵而不复制数据的示例： 译者注：这里的计数参考：Mat-基本的图像容器 123std::vector&lt;Point3f&gt; points;// .. fill the arrayMat pointsMat = Mat(points).reshape(1); 最后，我们得到了3列32FC1矩阵，而不是1列32FC3矩阵。 pointsMat使用来自点的数据，并且在销毁时不会释放内存。 然而，在这个特定的例子中，开发者必须确保points的寿命比pointsMat的长。 如果我们需要复制数据，则使用例如cv::Mat::copyTo或cv::Mat::clone的方法： 12Mat img = imread(\"image.jpg\");Mat img1 = img.clone(); 相反，如果C API需要由开发人员创建输出图像，则可以为每个函数提供一个空的Mat的输出。每一次使用Mat :: create实现目标矩阵。 如果该方法为空，则该方法为矩阵分配数据。 如果它不是空的并且具有正确的大小和类型，则该方法不做任何事情。 但是，如果大小或类型与输入参数不同，则会释放（并丢失）数据，并分配新数据。 例如：123Mat img = imread(\"image.jpg\");Mat sobelx;Sobel(img, sobelx, CV_32F, 1, 0); 原始的操作在矩阵上定义了许多方便的操作符。 例如，下面是我们如何从现有的灰度图像“img”中制作黑色图像：1img = Scalar(0); 选择一个感兴趣的区域(ROI)：12Rect r(10, 10, 100, 100);Mat smallImg = img(r); 从Mat到C API数据结构的转换：123Mat img = imread(\"image.jpg\");IplImage img1 = img;CvMat m = img; 请注意，这里没有数据复制。 从彩色转换到灰度：123Mat img = imread(\"image.jpg\"); // loading a 8UC3 imageMat grey;cvtColor(img, grey, COLOR_BGR2GRAY); 将图像类型从8UC1更改为32FC1： 1src.convertTo(dst, CV_32F); 可视化图像在开发过程中查看算法的中间结果是非常有用的。 OpenCV提供了一种可视化图像的便捷方式。 一个8U图像可以显示使用： 1234Mat img = imread(\"image.jpg\");namedWindow(\"image\", WINDOW_AUTOSIZE);imshow(\"image\", img);waitKey(); 对waitKey（）的调用会启动一个消息传递循环，等待“图像”窗口中的关键笔画。 32F图像需要转换为8U类型。 例如： 123456789101112Mat img = imread(\"image.jpg\");Mat grey;cvtColor(img, grey, COLOR_BGR2GRAY);Mat sobelx;Sobel(grey, sobelx, CV_32F, 1, 0);double minVal, maxVal;minMaxLoc(sobelx, &amp;minVal, &amp;maxVal); //find minimum and maximum intensitiesMat draw;sobelx.convertTo(draw, CV_8U, 255.0/(maxVal - minVal), -minVal * 255.0/(maxVal - minVal));namedWindow(\"image\", WINDOW_AUTOSIZE);imshow(\"image\", draw);waitKey(); 译者注：函数参考链接： cvtColor Sobel minMaxLoc waitkey 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-操作图像.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 在矩阵上进行掩码操作","slug":"【OpenCvTutorials3-1中文翻译】-在矩阵上进行掩码操作","date":"2018-02-05T05:10:49.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-在矩阵上进行掩码操作.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-在矩阵上进行掩码操作.html","excerpt":"Mask operations on matrices矩阵上的掩码操作非常简单。 我们的想法是，我们根据掩码矩阵（也称为内核）重新计算图像中的每个像素值。 该掩码保存的值将调整相邻像素（和当前像素）对新像素值的影响程度。 从数学的角度来看，我们用我们指定的数值进行加权平均。","text":"Mask operations on matrices矩阵上的掩码操作非常简单。 我们的想法是，我们根据掩码矩阵（也称为内核）重新计算图像中的每个像素值。 该掩码保存的值将调整相邻像素（和当前像素）对新像素值的影响程度。 从数学的角度来看，我们用我们指定的数值进行加权平均。 我们的测试案例让我们考虑一个图像对比度增强方法的问题。 基本上我们要使用下列公式申请图像的每个像素： 第一种表示法是使用公式，而第二种表示法是使用掩码的第一种表示法。 通过将掩码矩阵的中心（在由零 - 零指数标记的大写字母中）放在要计算的像素上并使用与重叠的矩阵值相乘的像素值相加来使用掩码。 这是一样的事情，但是在大矩阵的情况下，后面的符号更容易查找。 现在让我们看看如何使用基本像素访问方法或使用cv::filter2D函数来实现这一点。 基本方法函数的实现： 12345678910111213141516171819202122void Sharpen(const Mat&amp; myImage, Mat&amp; Result)&#123; CV_Assert(myImage.depth() == CV_8U); // accept only uchar images Result.create(myImage.size(), myImage.type()); const int nChannels = myImage.channels(); for(int j = 1; j &lt; myImage.rows - 1; ++j) &#123; const uchar* previous = myImage.ptr&lt;uchar&gt;(j - 1); const uchar* current = myImage.ptr&lt;uchar&gt;(j ); const uchar* next = myImage.ptr&lt;uchar&gt;(j + 1); uchar* output = Result.ptr&lt;uchar&gt;(j); for(int i = nChannels; i &lt; nChannels * (myImage.cols - 1); ++i) &#123; *output++ = saturate_cast&lt;uchar&gt;(5 * current[i] -current[i - nChannels] - current[i + nChannels] - previous[i] - next[i]); &#125; &#125; Result.row(0).setTo(Scalar(0)); Result.row(Result.rows - 1).setTo(Scalar(0)); Result.col(0).setTo(Scalar(0)); Result.col(Result.cols - 1).setTo(Scalar(0));&#125; 首先我们确保输入的图像数据是无符号的字符格式。 为此，我们使用cv::CV_Assert函数，当它里面的表达式为false时会抛出一个错误。 1CV_Assert(myImage.depth() == CV_8U); // accept only uchar images 我们创建一个与我们的输入具有相同大小和相同类型的输出图像。 正如你可以在图像存储部分看到的，取决于通道的数量，我们可能有一个或多个子列。 我们将通过指针遍历它们，所以元素的总数取决于这个数字。 12Result.create(myImage.size(), myImage.type());const int nChannels = myImage.channels(); 我们将使用普通的C []运算符来访问像素。 因为我们需要同时访问多行，我们将获取每个行的指针（前一行，当前行和下一行）。 我们需要另一个指向我们要保存计算的地方。 然后只需使用[]运算符访问正确的项目。 为了提前移动输出指针，我们只需在每个操作之后增加一个字节即可： 1234567891011121314for(int j = 1; j &lt; myImage.rows - 1; ++j)&#123; const uchar* previous = myImage.ptr&lt;uchar&gt;(j - 1); const uchar* current = myImage.ptr&lt;uchar&gt;(j ); const uchar* next = myImage.ptr&lt;uchar&gt;(j + 1); uchar* output = Result.ptr&lt;uchar&gt;(j); for(int i = nChannels; i &lt; nChannels * (myImage.cols - 1); ++i) &#123; *output++ = saturate_cast&lt;uchar&gt;(5 * current[i] -current[i - nChannels] - current[i + nChannels] - previous[i] - next[i]); &#125;&#125; 在图像的边界上面的符号导致不存在的像素位置例如(-1,-1)(like minus one - minus one).。 在这点我们的公式是不确定的。 一个简单的解决方案是不在这些点上应用内核，例如，将边界上的像素设置为零： 译者注：“在图像的边界上面的符号导致不存在的像素位置例如(-1,-1)(like minus one - minus one).&quot;在原文是“On the borders of the image the upper notation results inexistent pixel locations (like minus one - minus one). ”不好翻译，需要结合下面的代码理解一下，大概就是有些地方遍历不到，故直接进行赋值。 1234Result.row(0).setTo(Scalar(0)); // The top rowResult.row(Result.rows - 1).setTo(Scalar(0)); // The bottom rowResult.col(0).setTo(Scalar(0)); // The left columnResult.col(Result.cols - 1).setTo(Scalar(0)); // The right column filter2D函数应用这样的过滤器在图像处理中非常普遍，以至于在OpenCV中存在一个将处理掩码（在某些地方也称为内核）的函数。 为此，你首先需要定义一个Mat对象来保存这个掩码： 123Mat kern = (Mat_&lt;char&gt;(3,3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0); 然后调用cv::filter2D函数指定输入: 输出的图像和使用的内核 1filter2D(I, K, I.depth(), kern); 该函数甚至有第五个可选参数来指定内核的中心，第六个用于确定在未定义操作（边界）的区域中要做什么。 使用这个函数的优点是它更短，更简洁，并且由于实现了一些优化技术，所以通常比手工编码的方法更快。 例如在我的测试中，第二个只花了13毫秒，第一个花费了大约31毫秒。 有一些差异。 For example: 你可以从这里下载这个源代码，或者查看OpenCV源代码库的示例目录 samples/cpp/tutorial_code/core/mat_mask_operations/mat_mask_operations.cpp. 查看在我们的YouTube频道上运行该程序的实例。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-在矩阵上进行掩码操作.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】- 如何使用OpenCV扫描图像，查找表和时间测量","slug":"【OpenCvTutorials3-1中文翻译】-如何使用OpenCV扫描图像，查找表和时间测量","date":"2018-02-04T07:25:09.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-如何使用opencv扫描图像，查找表和时间测量.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-如何使用opencv扫描图像，查找表和时间测量.html","excerpt":"How to scan images, lookup tables and time measurement with OpenCV目标我们将为以下问题寻求答案： 如何通过图像的每个像素？ OpenCV矩阵值如何存储？ 如何衡量我们算法的性能？ 什么是查找表，为什么使用它们？","text":"How to scan images, lookup tables and time measurement with OpenCV目标我们将为以下问题寻求答案： 如何通过图像的每个像素？ OpenCV矩阵值如何存储？ 如何衡量我们算法的性能？ 什么是查找表，为什么使用它们？ 我们的测试用例让我们考虑一个简单的色彩还原方法。. 通过使用无符号字符C和C++矩阵项目存储，一个像素的渠道可能有多达256个不同的值。对于三通道图像这可能允许太多颜色的形成(确切的说是1600万)。工作有这么多颜色的色调可以给我们的算法性能的一个沉重的打击。但是，有时只用更少的工作就可以得到相同的最终结果。 在这种情况下，我们通常会减少色彩空间。 这意味着我们将色彩空间当前值与一个新的输入值分开，以较少的颜色结束。 例如，0与9之间的每个值都取新值0，10至19之间的每一个值10等等。 当你用一个int值分割一个uchar（unsigned char - 又名0到255之间的值）值时，结果也是char。 这些值可能只是char值。 因此，任何分数都会被舍入。 利用这个事实，uchar域中的上面的操作可以表示为： $$In= (\\frac {I_{o}}{10}) * 10.$$ In: I_new; Io: I_old; 一个简单的色彩空间减少算法将包括只是通过一个图像矩阵的每个像素应用这个公式。 值得注意的是，我们做了分裂和乘法运算。 这些操作对于一个系统来说是非常昂贵的。 如果可能的话，通过使用更便宜的操作（例如几次减法，加法或最好的情况下简单的分配）来避免它们是值得的。 此外，请注意，对于上层操作，我们只有有限的输入值。 在uchar系统的情况下，这是256。 因此，对于较大的图像，事先计算所有可能的值并在分配期间通过使用查找表来进行分配将是明智的。 查找表是简单的数组（具有一个或多个维度），对于给定的输入值变化保存最终的输出值。 它的优势在于我们不需要计算，我们只需要读取结果。 我们的测试用例程序（和这里提供的示例）将执行以下操作：读取控制台行参数图像（可能是彩色或灰度级 - 控制台行参数），并将缩减应用于给定的控制台行参数整数值。 在OpenCV中，目前，它们是逐个像素地进行图像处理的三种主要方式。 为了使事情变得更有趣，将使用所有这些方法扫描每个图像，并打印出需要多长时间。 您可以在这里下载完整的源代码，或者在核心部分的cpp教程代码中的OpenCV示例目录中查找它。 其基本用法是： 1how_to_scan_images imageName.jpg intValueToReduce [G] 最后的参数是可选的。 如果给定图像将以灰度格式加载，否则使用BGR色彩空间。 首先要计算查找表。 123456789101112int divideWith = 0; // convert our input string to number - C++ stylestringstream s;s &lt;&lt; argv[2];s &gt;&gt; divideWith;if (!s || !divideWith)&#123; cout &lt;&lt; \"Invalid number entered for dividing. \" &lt;&lt; endl; return -1;&#125;uchar table[256];for (int i = 0; i &lt; 256; ++i) table[i] = (uchar)(divideWith * (i/divideWith)); 在这里，我们首先使用C ++ stringstream类将第三个命令行参数从文本转换为整数格式。 然后我们简单的使用上面的公式来计算查找表。 在这里没有OpenCV特定的东西。 另一个问题是我们如何衡量时间？ 那么OpenCV提供了两个简单的函数来实现这个cv::getTickCount（）和cv::getTickFrequency（）。 第一个从特定事件返回系统CPU的滴答数（自引导系统以来）。 第二个返回你的CPU在一秒钟内发出一个刻度的次数。 因此，以秒为单位，两次操作之间的时间间隔很容易得到： 1234double t = (double)getTickCount();// do something ...t = ((double)getTickCount() - t)/getTickFrequency();cout &lt;&lt; \"Times passed in seconds: \" &lt;&lt; t &lt;&lt; endl; 图像矩阵如何存储在内存中？正如你已经阅读我的Mat-基本的图像容器教程矩阵的大小取决于使用的颜色系统。 更准确地说，这取决于使用的通道数量。 在灰度图像的情况下，我们有这样的东西： 对于多通道图像，列包含与通道数量一样多的子列。 例如在BGR颜色系统的情况下： 请注意，通道的顺序是相反的：BGR而不是RGB。 因为在许多情况下，存储器足够大以便按照连续的方式存储行，所以行可以一个接一个地跟随，从而创建单个长行。 因为所有东西都在一个接一个地方，这可能有助于加快扫描过程。 我们可以使用cv::Mat::isContinuous（）函数来询问矩阵是否属于这种情况。 继续下一节找到一个例子。 有效的方法当谈到性能，你不能击败经典的C风格运算符[]（指针）访问。 因此，我们可以推荐的最有效的方法是： 123456789101112131415161718192021222324Mat&amp; ScanImageAndReduceC(Mat&amp; I, const uchar* const table)&#123; // accept only char type matrices CV_Assert(I.depth() == CV_8U); int channels = I.channels(); int nRows = I.rows; int nCols = I.cols * channels; if (I.isContinuous()) &#123; nCols *= nRows; nRows = 1; &#125; int i,j; uchar* p; for( i = 0; i &lt; nRows; ++i) &#123; p = I.ptr&lt;uchar&gt;(i); for ( j = 0; j &lt; nCols; ++j) &#123; p[j] = table[p[j]]; &#125; &#125; return I;&#125; 在这里，我们基本上只是获取一个指向每一行开始的指针并遍历它直到它结束。 在矩阵以连续方式存储的特殊情况下，我们只需要一次指针并一直走到最后。 我们需要注意彩色图像：我们有三个通道，所以我们需要在每一行中通过三次以上的项目(iterm)。 还有另一种方法。 Mat对象的数据数据成员将指针返回到第一行第一列。 如果这个指针为空，那么在该对象中没有有效的输入。 检查这是检查您的图像加载是否成功的最简单的方法。 如果存储是连续的，我们可以使用这个来遍历整个数据指针。 在灰度图像的情况下，这将看起来像： 123uchar* p = I.data;for( unsigned int i =0; i &lt; ncol*nrows; ++i) *p++ = table[*p]; 你会得到相同的结果。 但是，这个代码在以后很难阅读。 如果你有一些进阶的技巧，那就更难了。 此外，在实践中，我发现你会得到相同的性能结果（因为大多数现代编译器可能会自动为你做这个小优化技巧）。 迭代器（安全）的方法上一个有效的方法（efficient way）可能确定您通过适当数量的uchar字段，而且跳过行之间可能发生的差距是您的责任。 迭代器方法被认为是一个更安全的方式，因为它接管用户的这些任务。 所有你需要做的是要求图像矩阵的开始和结束，然后增加开始迭代器直到你到达最后。 要获取迭代器指向的值，请使用*运算符（在它之前添加它）。 1234567891011121314151617181920212223242526Mat&amp; ScanImageAndReduceIterator(Mat&amp; I, const uchar* const table)&#123; // accept only char type matrices CV_Assert(I.depth() == CV_8U); const int channels = I.channels(); switch(channels) &#123; case 1: &#123; MatIterator_&lt;uchar&gt; it, end; for( it = I.begin&lt;uchar&gt;(), end = I.end&lt;uchar&gt;(); it != end; ++it) *it = table[*it]; break; &#125; case 3: &#123; MatIterator_&lt;Vec3b&gt; it, end; for( it = I.begin&lt;Vec3b&gt;(), end = I.end&lt;Vec3b&gt;(); it != end; ++it) &#123; (*it)[0] = table[(*it)[0]]; (*it)[1] = table[(*it)[1]]; (*it)[2] = table[(*it)[2]]; &#125; &#125; &#125; return I; 在彩色图像的情况下，每列有三个uchar项目。 这可能被认为是一个short的uchar向量，它已经在OpenCV中有了Vec3b这个名称。 要访问第n个子列，我们使用简单的operator []访问。 记住OpenCV迭代器遍历列并自动跳到下一行是很重要的。 因此，如果使用简单的uchar迭代器，在彩色图像的情况下，您将只能访问蓝色通道值。 带参考返回的实时地址计算最后的方法不建议用于扫描。 它是为了获取或修改图像中的随机元素。 它的基本用法是指定要访问的项目的行号和列号。 在我们早期的扫描方法中，您可能已经注意到，通过我们正在查看图像的类型，这很重要。 这里没有什么不同，因为您需要手动指定在自动查找中使用的类型。 你可以在下面的源代码（+ cv::at（）函数的使用）的灰度图像的情况下观察这个： 123456789101112131415161718192021222324252627282930Mat&amp; ScanImageAndReduceRandomAccess(Mat&amp; I, const uchar* const table)&#123; // accept only char type matrices CV_Assert(I.depth() == CV_8U); const int channels = I.channels(); switch(channels) &#123; case 1: &#123; for( int i = 0; i &lt; I.rows; ++i) for( int j = 0; j &lt; I.cols; ++j ) I.at&lt;uchar&gt;(i,j) = table[I.at&lt;uchar&gt;(i,j)]; break; &#125; case 3: &#123; Mat_&lt;Vec3b&gt; _I = I; for( int i = 0; i &lt; I.rows; ++i) for( int j = 0; j &lt; I.cols; ++j ) &#123; _I(i,j)[0] = table[_I(i,j)[0]]; _I(i,j)[1] = table[_I(i,j)[1]]; _I(i,j)[2] = table[_I(i,j)[2]]; &#125; I = _I; break; &#125; &#125; return I;&#125; 这些功能将输入您的输入类型和坐标，并实时计算查询项目的地址。 然后返回一个参考。 当您get该值时，这可能是一个常量，而当您set该值时，该值可能是不恒定的。 作为仅在debug模式下的安全步骤*将执行一次检查，确认您的输入坐标是有效的并且确实存在。 如果不是这种情况，你会在标准错误输出流中得到一个很好的输出消息。 与release模式中的高效方式相比，使用这种方法的唯一区别是，对于图像的每个元素，您将获得一个新的行指针，用于我们使用C运算符[]获取列元素。 如果您需要使用此方法对图像进行多次查找，那么输入每个访问的类型和at关键字可能会很麻烦并且非常耗时。 为了解决这个问题，OpenCV有一个cv::Mat_数据类型。 与Mat相同，额外的需求是在定义时需要通过查看数据矩阵来指定数据类型，但是作为回报，您可以使用operator（）来快速访问项目。 为了使事情更好，这很容易转换到通常的cv :: Mat数据类型。 上面的函数的彩色图像的情况下，您可以看到一个示例用法。 不过，需要注意的是，使用cv::at（）函数可以完成相同的操作（具有相同的运行时速度）。 这只是懒惰的程序员技巧写的。 核心函数这是一个在图像中实现查找表修改的额外方法。 因为在图像处理中，您想要将所有给定的图像值替换为其他值，这是相当普遍的。OpenCV具有一个功能，无需编写图像扫描即可进行修改。 我们使用核心模块的cv::LUT（）函数。 首先我们建立一个Mat查找表的类型： 1234Mat lookUpTable(1, 256, CV_8U);uchar* p = lookUpTable.ptr();for( int i = 0; i &lt; 256; ++i) p[i] = table[i]; 最后调用函数（我是我们的输入图像，J是输出图像）： 1LUT(I, lookUpTable, J); 性能差异为了得到最好的结果，编译程序并以你自己的速度运行。 为了展示更好的差异，我使用了一个相当大的（2560 X 1600）图像。 这里介绍的性能是彩色图像。 为了获得更准确的值，我已经从函数调用中获得了数百次的平均值。 方法 时间 高效的方式 79.4717毫秒 迭代器 83.7201毫秒 实时性计算 93.7878毫秒 LUT函数 32.5759毫秒 总结一下。 如果可能的话，使用OpenCV已经完成的功能（而不是重新创建这些功能）。 最快的方法就是LUT功能。 这是因为OpenCV库是通过Intel Threaded Building Blocks启用的多线程。 但是，如果您需要编写一个简单的图像扫描更喜欢指针的方法。 迭代器是一个更安全的，但相当慢。 在Debug模式下，使用实时参考访问方法进行全图像扫描是成本最高的。 在release模式下，它可能会打败迭代器的方法，但它肯定会牺牲迭代器的安全特性。 最后，您可以在YouTube频道上发布的视频中观看该节目的示例。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-如何使用opencv扫描图像，查找表和时间测量.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"【OpenCvTutorials3.1中文翻译】-[Mat-基本的图像容器]","slug":"【OpenCvTutorials3-1中文翻译】- Mat-基本的图像容器","date":"2018-02-04T06:16:25.000Z","updated":"2018-07-15T13:23:40.681Z","comments":true,"path":"posts/【opencvtutorials3-1中文翻译】-mat-基本的图像容器.html","link":"","permalink":"http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-mat-基本的图像容器.html","excerpt":"Mat-基本的图像容器Goal我们有许多方法从现实世界中获取数字图像：数码相机、扫描仪、计算机断层扫描和核磁共振成像等。在任何情况下，我们（人类）看到的都是图像，但是将其转换为数字设备时，我们记录的便是图像中每一点的数字化的值。 例如，在上面的图片中，您可以看到汽车只不过表现为一个包含像素点所有强度值的矩阵。我们如何获取和存储像素值可能会根据我们的需要而有所不同，但最终计算机世界中的所有图像可能会被简化为描述矩阵本身的数字矩阵和其他信息。OpenCV是一个计算机视觉库，其重点是处理和操作这些信息。 因此，您首先需要熟悉的是OpenCV如何存储和处理图像。","text":"Mat-基本的图像容器Goal我们有许多方法从现实世界中获取数字图像：数码相机、扫描仪、计算机断层扫描和核磁共振成像等。在任何情况下，我们（人类）看到的都是图像，但是将其转换为数字设备时，我们记录的便是图像中每一点的数字化的值。 例如，在上面的图片中，您可以看到汽车只不过表现为一个包含像素点所有强度值的矩阵。我们如何获取和存储像素值可能会根据我们的需要而有所不同，但最终计算机世界中的所有图像可能会被简化为描述矩阵本身的数字矩阵和其他信息。OpenCV是一个计算机视觉库，其重点是处理和操作这些信息。 因此，您首先需要熟悉的是OpenCV如何存储和处理图像。 Mat 自从2001年以来，OpenCV就已经出现了。那时候，这个库是围绕一个C接口构建 的，并且将图像存储在内存中，他们使用了一个被称为IplImage的C结构体。 在大多数较老的教程和教材中，您将看到这一点。这个问题就是把C语言的所有缺点都展现了出来。最大的问题是手动内存管理。它建立在假定用户负责照顾内存分配和取消分配。虽然这对于较小的程序来说并不是问题，但是一旦你的代码库增长，处理所有这些将更加困难，而不是专注于解决你的开发目标。 幸运的是，C ++出现了，通过自动内存管理（或多或少）引入了类的概念，使用户更容易。 好消息是C ++与C完全兼容，所以不会出现兼容性问题。 因此，OpenCV 2.0引入了一个新的C ++接口，它提供了一种新的处理方式，这意味着你不需要进行内存管理，使你的代码简洁（少写，实现更多）。 C ++接口的主要缺点是目前许多嵌入式开发系统只支持C.因此，除非你是针对嵌入式平台，否则使用旧的方法是没有意义的（除非你是个受虐狂的程序员，否则你就是自找麻烦）。 关于Mat你首先需要了解，你不再需要手动分配内存，和在不需要的时候释放内存。虽然这样做仍然是可能的，但大部分OpenCV函数都会自动分配输出数据。一个额外的好处是，如果你传递一个已经存在的Mat对象（这个对象已经为矩阵分配了所需的空间），并且它将被重用。 Mat基本上是一个包含两个数据部分的类：矩阵头部（包含矩阵大小，用于存储的方法，存储矩阵的地址等信息）以及包含的像素值（取决于所选择的存储方法取任何维度）。 矩阵头的大小是恒定的，但是矩阵本身的大小可能会随着图像的不同而变化，并且通常会大几个数量级。 OpenCV是一个图像处理库。 它包含大量的图像处理功能。 为了解决计算上的挑战，大多数时候你最终会使用库的多个函数。 因此，将图像传递给函数是一种常见的做法。 我们不应该忘记，我们正在谈论的图像处理算法，往往是相当计算量。 我们最不愿做的就是进一步降低程序的速度，使程序中潜在不必要的大图像的副本。 为了解决这个问题，OpenCV使用了一个引用计数系统。这个想法是，每个Mat对象都有它自己的头，但是矩阵可以通过使它们的矩阵指针指向相同的地址而在它们的两个实例之间共享。 而且，复制操作符只会将头部和指针复制到大矩阵，而不是数据本身。 1234Mat A, C; // creates just the header partsA = imread(argv[1], IMREAD_COLOR); // here we'll know the method used (allocate matrix)Mat B(A); // Use the copy constructorC = A; // Assignment operator 上述所有的对象最后指向同一个单一的数据矩阵。 然而，他们的headers是不同的，使用它们中的任何一个都会影响其他所有的headers。 实际上，不同的对象只是为相同的基础数据提供不同的访问方法。 不过，他们的headers是不同的。 真正有趣的部分是，你可以创建headers，只引用全部数据的一个小节。 例如，要在图像中创建感兴趣区域（ROI），只需使用新边界创建一个新的headers： 12Mat D (A, Rect(10, 10, 100, 100) ); // using a rectangleMat E = A(Range::all(), Range(1,3)); // using row and column boundaries 现在您可能会问，矩阵本身是否属于多个Mat对象，在不再需要的时候，Mat对象负责清理它。 关于这个问题的简短的回答是：使用它的最后一个对象。 这是通过使用引用计数机制来处理的。 每当有人复制一个Mat对象的头部时，矩阵的计数器就增加了。 每当头部被清除时，这个计数器就会减少。 当计数器达到零时，矩阵也被释放。 有时你也想复制矩阵本身，所以OpenCV提供了cv::Mat::clone（）和cv::Mat::copyTo（）函数。 123Mat F = A.clone();Mat G;A.copyTo(G); 现在修改F或G不会影响Mat头指向的矩阵。 你需要记住的是： OpenCV函数的输出图像分配是自动的（除非另有规定）。 您不需要考虑使用OpenCV的C ++接口进行内存管理。 赋值运算符和复制构造函数只复制标题。 图像的底层矩阵可以使用cv::Mat::clone（）和cv::Mat::copyTo（）函数来复制。 存储方法这是关于如何存储像素值。 您可以选择使用的颜色空间和数据类型。 色彩空间是指我们如何组合颜色组件以编码给定的颜色。 最简单的就是我们可以使用的颜色是黑色和白色的灰度。 这些组合让我们创造出许多灰色梯度。 对于彩色的储存方式，我们有更多的方法供选择。对于丰富多彩的方式，我们有更多的方法可供选择。 他们每个分解成三个或四个基本组件，我们可以使用这些组合来创建其他。 最流行的是RGB，主要是因为这也是我们的眼睛如何建立颜色。 它的基本颜色是红色，绿色和蓝色。 为了编码颜色的透明度，有时需要添加第四个元素：alpha（A）。 然而，还有许多其他颜色系统各有其优点： RGB是最常见的，因为我们的眼睛使用类似的东西，但请记住，OpenCV标准显示系统使用BGR色彩空间（红色和蓝色通道的开关）组合颜色。 HSV和HLS将颜色分解为色调，饱和度和亮度/亮度分量，这是我们描述颜色的更自然的方式。 例如，您可能会忽略最后一个组件，从而使您的算法对输入图像的光照条件不那么敏感。 YCrCb被流行的JPEG图像格式所使用。 CIE L a b* 是一个感知上均匀的颜色空间，如果您需要测量给定颜色与另一种颜色之间的距离，则该颜色空间非常方便。 每一个组成的组建都有他们的有效域， 这决定了使用的数据类型。我们如何存储组件定义了我们对其域的控制权。 可能的最小数据类型是char，也就是一个字节或8位。这可能是无符号的（所以可以存储从0到255的值）或有符号的（从-127到+127的值）。尽管在三个组成部分的情况下，这已经提供了1600万个可能的颜色来表示（比如在RGB的情况下），我们可以通过使用float（4字节= 32位）或者double（8字节= 64位）数据来更精细的控制每个组成部分。不过，请记住，增加组件的大小也会增加内存中整个图片的大小。 显式创建一个Mat对象在Load, Modify, and Save an Image教程中，您已经学习了如何使用cv :: imwrite（）函数将矩阵写入图像文件。 但是，出于调试目的，查看实际值要方便得多。 您可以使用Mat的&lt;&lt;运算符来执行此操作。 请注意，这只适用于二维矩阵。 尽管Mat作为一个图像容器非常适合，它也是一个通用的矩阵类。 因此，可以创建和操作多维矩阵。 您可以通过多种方式创建一个Mat对象： cv::Mat::Mat 构造函数：12Mat M(2,2, CV_8UC3, Scalar(0,0,255));cout &lt;&lt; \"M = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl; 对于二维和多通道图像，我们首先定义它们的大小：明智的行和列的数目。 然后，我们需要指定用于存储元素的数据类型和每个矩阵点的通道数量。 要做到这一点，我们有多个按照以下惯例构建的定义： 1CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number] 例如，CV_8UC3意味着我们使用8位长的无符号字符类型，每个像素有三个这样的字符串来形成三个通道。 这是预定义的最多四个通道数目。cv :: Scalar是四元素的short矢量。 指定这个，你可以用一个自定义的值初始化所有的矩阵点。 如果您需要更多，您可以使用上面的宏创建类型，如下所示在括号中设置通道号。 使用C / C ++数组并通过构造函数初始化 12int sz[3] = &#123;2,2,2&#125;;Mat L(3,sz, CV_8UC(1), Scalar::all(0)); 上面的例子展示了如何创建一个具有两个以上维度的矩阵。 指定其维度，然后传递包含每个维度大小的指针，其余维持不变。 cv :: Mat :: create函数： 12M.create(4,4, CV_8UC(2));cout &lt;&lt; \"M = \"&lt;&lt; endl &lt;&lt; \" \" &lt;&lt; M &lt;&lt; endl &lt;&lt; endl; 这种结构不能初始化矩阵值。 如果新的尺寸不适合旧的，它将只重新分配它的矩阵数据存储器。 MATLAB风格初始值设定项：cv::Mat::zeros，cv::Mat::ones，cv::Mat::eye。 指定要使用的大小和数据类型：123456Mat E = Mat::eye(4, 4, CV_64F);cout &lt;&lt; \"E = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;Mat O = Mat::ones(2, 2, CV_32F);cout &lt;&lt; \"O = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;Mat Z = Mat::zeros(3,3, CV_8UC1);cout &lt;&lt; \"Z = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl; 对于小型矩阵，您可以使用逗号分隔的初始值设定项： 12Mat C = (Mat_&lt;double&gt;(3,3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);cout &lt;&lt; \"C = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; C &lt;&lt; endl &lt;&lt; endl; 为现有的Mat对象和cv::Mat::clone或cv::Mat::copyTo创建一个新的头部。 12Mat RowClone = C.row(1).clone();cout &lt;&lt; \"RowClone = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl; Note:你可以使用 cv :: randu（）函数填充随机值的矩阵。 您需要给出随机值的下限和上限值：12Mat R = Mat(3, 2, CV_8UC3);randu(R, Scalar::all(0), Scalar::all(255)); 输出格式在上面的例子中，你可以看到默认的格式化选项。 然而，OpenCV允许你格式化你的矩阵输出： Default: 1cout &lt;&lt; \"R (default) = \" &lt;&lt; endl &lt;&lt; R &lt;&lt; endl &lt;&lt; endl; Python: 1cout &lt;&lt; \"R (python) = \" &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_PYTHON) &lt;&lt; endl &lt;&lt; endl; Comma separated values (CSV):1cout &lt;&lt; \"R (csv) = \" &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_CSV ) &lt;&lt; endl &lt;&lt; endl; Numpy: 1cout &lt;&lt; \"R (c) = \" &lt;&lt; endl &lt;&lt; format(R, Formatter::FMT_C ) &lt;&lt; endl &lt;&lt; endl; 其他常见项目的输出OpenCV也支持通过&lt;&lt;运算符来输出其他常见的OpenCV数据结构： 2D Point: 12Point2f P(5, 1);cout &lt;&lt; \"Point (2D) = \" &lt;&lt; P &lt;&lt; endl &lt;&lt; endl; 3D Point: 12Point3f P3f(2, 6, 7);cout &lt;&lt; \"Point (3D) = \" &lt;&lt; P3f &lt;&lt; endl &lt;&lt; endl; std::vector via cv::Mat 123vector&lt;float&gt; v;v.push_back( (float)CV_PI); v.push_back(2); v.push_back(3.01f);cout &lt;&lt; \"Vector of floats via Mat = \" &lt;&lt; Mat(v) &lt;&lt; endl &lt;&lt; endl; std::vector of points： 1234vector&lt;Point2f&gt; vPoints(20);for (size_t i = 0; i &lt; vPoints.size(); ++i) vPoints[i] = Point2f((float)(i * 5), (float)(i % 7));cout &lt;&lt; \"A vector of 2D Points = \" &lt;&lt; vPoints &lt;&lt; endl &lt;&lt; endl; 这里的大部分示例都包含在一个小的控制台应用程序中。 您可以从这里或cpp示例的核心部分下载它。 你也可以在YouTube上找到这个快速的视频演示。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencvtutorials3-1中文翻译】-mat-基本的图像容器.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCvTutorials3.1中文翻译","slug":"OpenCvTutorials3-1中文翻译","permalink":"http://little-rocket.cn/tags/OpenCvTutorials3-1中文翻译/"}]},{"title":"C++ 结合gnuplot实现数据可视化【2】-分享一个写得不错的中文教程","slug":"C-结合gnuplot实实现数据可视化【2】_分享一个写得不错的中文教程","date":"2018-01-27T13:47:53.000Z","updated":"2018-02-21T10:28:54.178Z","comments":true,"path":"posts/c-结合gnuplot实现数据可视化【2】-分享一个写得不错的中文教程.html","link":"","permalink":"http://little-rocket.cn/posts/c-结合gnuplot实现数据可视化【2】-分享一个写得不错的中文教程.html","excerpt":"文档看到脑阔痛，唉，英语太差了，然后顺便谷歌了一下，发现了一只野生中文文档教程，感觉还不错，分享一下：","text":"文档看到脑阔痛，唉，英语太差了，然后顺便谷歌了一下，发现了一只野生中文文档教程，感觉还不错，分享一下： 中文的： 中文教程传送门 官方的： 官方教程 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/c-结合gnuplot实现数据可视化【2】-分享一个写得不错的中文教程.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"C++的数据可视化","slug":"C-的数据可视化","permalink":"http://little-rocket.cn/tags/C-的数据可视化/"}]},{"title":"C++ 结合gnuplot实现数据可视化【1】","slug":"C-结合gnuplot实实现数据可视化【1】","date":"2018-01-27T09:30:26.000Z","updated":"2018-07-15T13:23:40.681Z","comments":true,"path":"posts/c-结合gnuplot实现数据可视化【1】.html","link":"","permalink":"http://little-rocket.cn/posts/c-结合gnuplot实现数据可视化【1】.html","excerpt":"C++的优秀的数据可视化库太少了，平时写OpenCv的时候想作一下图，达到可视化，于是乎，强行谷歌了2天，尝试了网上推荐的很多绘图库，编译啊， 编译啊，啊，，反正就是各种BUG，最后发现了这个gnuplot；然后网上的那个Demo也都是Copy过去Copy过来的，，效果图也没有，惊了；我在这里总结一下，希望能够帮助到和我有同样问题的同学。","text":"C++的优秀的数据可视化库太少了，平时写OpenCv的时候想作一下图，达到可视化，于是乎，强行谷歌了2天，尝试了网上推荐的很多绘图库，编译啊， 编译啊，啊，，反正就是各种BUG，最后发现了这个gnuplot；然后网上的那个Demo也都是Copy过去Copy过来的，，效果图也没有，惊了；我在这里总结一下，希望能够帮助到和我有同样问题的同学。 安装： 官网：http://www.gnuplot.info/这是个软件，但是打开之后，就是个命令行，类似于Matlab： 在C++调用： 首先把gnuplot.exe的目录添加到Path环境变量： 在C++中调用的Demo： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; char*gnuplotPath = \"gnuplot.exe\"; FILE* gp = _popen(gnuplotPath,\"w\"); if (gp == NULL) &#123; cout&lt;&lt;(\"Cannotopen gnuplot!\\n\")&lt;&lt;endl;; return 0; //exit(0); &#125; fprintf(gp,\"plot sin(x)\\n\"); fprintf(gp,\"pause mouse\\n\");//用户点击后退出 _pclose(gp);&#125; 效果图： 网上大佬封装的C++库： Github 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/c-结合gnuplot实现数据可视化【1】.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"C++的数据可视化","slug":"C-的数据可视化","permalink":"http://little-rocket.cn/tags/C-的数据可视化/"}]},{"title":"【OpenCv小白入门】人脸检测","slug":"【OpenCv小白入门】人脸检测","date":"2018-01-26T03:28:07.000Z","updated":"2018-07-15T13:23:40.691Z","comments":true,"path":"posts/【opencv小白入门】人脸检测.html","link":"","permalink":"http://little-rocket.cn/posts/【opencv小白入门】人脸检测.html","excerpt":"本篇小结是关于OpenCv小白入门的，分享一下自己的想法，并且较为详细的总结一下利用OpenCv自带的Haar分类器进行人脸检测以及基于OpenCV3.1+Vs2013+C++的具体代码实现。","text":"本篇小结是关于OpenCv小白入门的，分享一下自己的想法，并且较为详细的总结一下利用OpenCv自带的Haar分类器进行人脸检测以及基于OpenCV3.1+Vs2013+C++的具体代码实现。 没有实际的操作，一切都是扯淡：怎么说，在我刚刚开始学习OpenCv的时候，疯狂的被安利学习OpenCV(中文版)和数字图像处理不可否认，这些书确实是挺不错的，我也确实想把他们都细细的啃完；But，一考虑自己这个记忆力，怕是看完就忘记完了哦，再结合某人士说的，我们是站在巨人的肩膀上的，我们应该从作中学，没有实际的操作，一切都是扯淡！ 于是，借助OpenCv的友情链接的教程OpenCV Tutorial (C++)快速实现了入门。之后，再借助国内码云找到了若干小项目练手。 微信跳一跳，辅助程序， 有兴趣的可以瞅瞅：github 然后，根据自己的兴趣，开始学习人脸检测 实际操作：* 区别人脸检测和人脸识别：人脸检测和人脸识别的区别 * 代码的具体实现过程： 这一段，前半部分主要是函数的声明，全局变量的声明，以及准备训练好的分类器文件； 后面的main函数里面有2个函数， 分别是利用图片和摄像头作为输入，进行实时检测，这里只需要讲解图片作为输入即可。 由于以及有了OpenCv训练好了的分类器文件，我们就只需要使用load这个方法进行加载即可: 1bool cv::CascadeClassifier::load(const String &amp; filename) 把图像转为黑白图像,并且进行直方图均衡文档： 12cvtColor(src_img, gray_img, COLOR_BGR2GRAY);equalizeHist(gray_img, gray_img); 利用detectMultiScale加载分类器，对输入的图像进行检测： 12face_cascade.detectMultiScale(gray_img, faces, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));eyes_cascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(50, 50)); 遍历检测到的所有脸，利用ellipse绘制椭圆，标记检测到的脸；由于眼睛是长在脸上的这个真理，在找到脸的基础上，利用detectMultiScale加载分类器，检测眼睛，并且利用circle绘制圆，做出标记： 1234567891011121314151617181920//-- Detect facesface_cascade.detectMultiScale(gray_img, faces, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));for (size_t i = 0; i &lt; faces.size(); i++)&#123; Point center(faces[i].x + faces[i].width / 2, faces[i].y + faces[i].height / 2); ellipse(gray_img, center, Size(faces[i].width / 2, faces[i].height / 2), 0, 0, 360, Scalar(255, 0, 255), 4, 8, 0); Mat faceROI = gray_img(faces[i]); cout &lt;&lt; \"i: \" &lt;&lt; i&lt;&lt; endl; std::vector&lt;Rect&gt; eyes; //-- In each face, detect eyes eyes_cascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(50, 50)); for (size_t j = 0; j &lt; eyes.size(); j++) &#123; Point eye_center(faces[i].x + eyes[j].x + eyes[j].width / 2, faces[i].y + eyes[j].y + eyes[j].height / 2); int radius = cvRound((eyes[j].width + eyes[j].height)*0.25); //获取半径、cvRound将浮点数四舍五入到最接近的整数。 cout &lt;&lt; \"radius: \"&lt;&lt;radius &lt;&lt; endl; circle(gray_img, eye_center, radius, Scalar(255, 0, 0), 4, 8, 0); &#125;&#125; 然后， imshow出来就是了 效果图以及源代码： github 接下来的计划：这个玩意，其实最核心还是那个分类器，计划下一步，去找个网站，用py写一条健壮的爬虫，整个几千张图下来，用python训练个分类器，检测一些其他的东西。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/【opencv小白入门】人脸检测.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"OpenCv","slug":"OpenCv","permalink":"http://little-rocket.cn/tags/OpenCv/"},{"name":"项目","slug":"项目","permalink":"http://little-rocket.cn/tags/项目/"}]},{"title":"Windows10下好用的几只软件","slug":"Windows10下好用的几只软件","date":"2018-01-12T08:14:34.000Z","updated":"2018-02-21T10:28:54.179Z","comments":true,"path":"posts/windows10下好用的几只软件.html","link":"","permalink":"http://little-rocket.cn/posts/windows10下好用的几只软件.html","excerpt":"Windows下也有许多也许小众但是贼有用的软件工具，他们能够让我们更加高效的使用windows。","text":"Windows下也有许多也许小众但是贼有用的软件工具，他们能够让我们更加高效的使用windows。 Notepad++ 简介Notepad++是一个免费的源代码编辑器和记事本替换，支持多种语言。在MS Windows环境中运行，其使用受GPL许可证管理。 特点1、 它能够帮助我们快速，方便的作笔记，我们可以甚至可以用“.py”来保存我们的笔记， 以使得它能够高亮显示；2、它致力于保护环境而尽可能的占用电脑的CPU，正如它的网站上说的那样: “ Notepad++ is trying to reduce the world carbon dioxide emissions. When using less CPU power, the PC can throttle down and reduce power consumption, resulting in a greener environment.” Everything 简介Everything 是一个私有的免费Windows桌面搜索引擎，可以在NTFS卷上快速地根据名称查找文件和目录。由澳大利亚人大卫·卡彭特（David Carpenter）开发。 特点再也不用担心找不到某个角落的文件了；不用怕系统垃圾清理因为找不到目录而无法清理了。更多的优点，请访问voidtools. SuperRun 简介一款快速启动软件。设计理念是全键盘操作，自动索引，绝对不允许一个一个命令的手动添加。运行以后会自动覆盖Win+R键盘快捷键，按下即可呼出。支持模糊搜索，支持拼音搜索。简单纯粹的界面，输入!即可进入命令模式。 特点可以代替Win+R不使用鼠标， 直接可以选择运行软件。 Teamviwer 简介TeamViewer是一个能在任何防火墙和NAT代理的后台用于远程控制的应用程序，桌面共享和文件传输的简单且快速的解决方案。 特点为了连接到另一台计算机/手机，只需要在两台计算机/手机上同时运行 TeamViewer 即可该软件第一次启动在两台计算机/手机上自动生成伙伴 ID。只需要输入你的伙伴的ID到TeamViewer，然后就会立即建立起连接。 Rainmeter 简介Rainmeter允许您在桌面上显示可定制的皮肤，从硬件使用度量工具到全功能音频可视化工具。你只受到你的想象力和创造力的限制。Rainmeter是根据GNU GPL v2许可证条款免费分发的开源软件。 ###特点谁说只有linux的开源桌面我们才能定制的，有了Rainmeter,桌面什么样子全部都只受到自己的想象力的约束了。 最后网络上有许许多多的优秀的软件，工具。在这里提出的不过是冰山一角而已，但是也希望能够帮助到你。 本作品采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但是请注明来自little-rocket-blog，并保证转载后文章的完整性。本人保留所有版权相关权利。 本文链接：http://little-rocket.cn/posts/windows10下好用的几只软件.html","categories":[{"name":"zhangcaocao","slug":"zhangcaocao","permalink":"http://little-rocket.cn/categories/zhangcaocao/"}],"tags":[{"name":"资源分享","slug":"资源分享","permalink":"http://little-rocket.cn/tags/资源分享/"}]}]}